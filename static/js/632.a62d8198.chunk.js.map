{"version":3,"file":"static/js/632.a62d8198.chunk.js","mappings":"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","sources":["../node_modules/zrender/lib/tool/convertPath.js","../node_modules/zrender/lib/tool/dividePath.js","../node_modules/zrender/lib/tool/morphPath.js","../node_modules/echarts/lib/animation/morphTransitionHelper.js","../node_modules/echarts/lib/animation/universalTransition.js","../node_modules/echarts/lib/label/LabelManager.js","../node_modules/echarts/lib/label/installLabelLayout.js","../node_modules/echarts/lib/data/DataDiffer.js","../node_modules/echarts/lib/label/labelGuideHelper.js"],"sourcesContent":["import { cubicSubdivide } from '../core/curve.js';\nimport PathProxy from '../core/PathProxy.js';\nvar CMD = PathProxy.CMD;\nfunction aroundEqual(a, b) {\n    return Math.abs(a - b) < 1e-5;\n}\nexport function pathToBezierCurves(path) {\n    var data = path.data;\n    var len = path.len();\n    var bezierArrayGroups = [];\n    var currentSubpath;\n    var xi = 0;\n    var yi = 0;\n    var x0 = 0;\n    var y0 = 0;\n    function createNewSubpath(x, y) {\n        if (currentSubpath && currentSubpath.length > 2) {\n            bezierArrayGroups.push(currentSubpath);\n        }\n        currentSubpath = [x, y];\n    }\n    function addLine(x0, y0, x1, y1) {\n        if (!(aroundEqual(x0, x1) && aroundEqual(y0, y1))) {\n            currentSubpath.push(x0, y0, x1, y1, x1, y1);\n        }\n    }\n    function addArc(startAngle, endAngle, cx, cy, rx, ry) {\n        var delta = Math.abs(endAngle - startAngle);\n        var len = Math.tan(delta / 4) * 4 / 3;\n        var dir = endAngle < startAngle ? -1 : 1;\n        var c1 = Math.cos(startAngle);\n        var s1 = Math.sin(startAngle);\n        var c2 = Math.cos(endAngle);\n        var s2 = Math.sin(endAngle);\n        var x1 = c1 * rx + cx;\n        var y1 = s1 * ry + cy;\n        var x4 = c2 * rx + cx;\n        var y4 = s2 * ry + cy;\n        var hx = rx * len * dir;\n        var hy = ry * len * dir;\n        currentSubpath.push(x1 - hx * s1, y1 + hy * c1, x4 + hx * s2, y4 - hy * c2, x4, y4);\n    }\n    var x1;\n    var y1;\n    var x2;\n    var y2;\n    for (var i = 0; i < len;) {\n        var cmd = data[i++];\n        var isFirst = i === 1;\n        if (isFirst) {\n            xi = data[i];\n            yi = data[i + 1];\n            x0 = xi;\n            y0 = yi;\n            if (cmd === CMD.L || cmd === CMD.C || cmd === CMD.Q) {\n                currentSubpath = [x0, y0];\n            }\n        }\n        switch (cmd) {\n            case CMD.M:\n                xi = x0 = data[i++];\n                yi = y0 = data[i++];\n                createNewSubpath(x0, y0);\n                break;\n            case CMD.L:\n                x1 = data[i++];\n                y1 = data[i++];\n                addLine(xi, yi, x1, y1);\n                xi = x1;\n                yi = y1;\n                break;\n            case CMD.C:\n                currentSubpath.push(data[i++], data[i++], data[i++], data[i++], xi = data[i++], yi = data[i++]);\n                break;\n            case CMD.Q:\n                x1 = data[i++];\n                y1 = data[i++];\n                x2 = data[i++];\n                y2 = data[i++];\n                currentSubpath.push(xi + 2 / 3 * (x1 - xi), yi + 2 / 3 * (y1 - yi), x2 + 2 / 3 * (x1 - x2), y2 + 2 / 3 * (y1 - y2), x2, y2);\n                xi = x2;\n                yi = y2;\n                break;\n            case CMD.A:\n                var cx = data[i++];\n                var cy = data[i++];\n                var rx = data[i++];\n                var ry = data[i++];\n                var startAngle = data[i++];\n                var endAngle = data[i++] + startAngle;\n                i += 1;\n                var anticlockwise = !data[i++];\n                x1 = Math.cos(startAngle) * rx + cx;\n                y1 = Math.sin(startAngle) * ry + cy;\n                if (isFirst) {\n                    x0 = x1;\n                    y0 = y1;\n                    createNewSubpath(x0, y0);\n                }\n                else {\n                    addLine(xi, yi, x1, y1);\n                }\n                xi = Math.cos(endAngle) * rx + cx;\n                yi = Math.sin(endAngle) * ry + cy;\n                var step = (anticlockwise ? -1 : 1) * Math.PI / 2;\n                for (var angle = startAngle; anticlockwise ? angle > endAngle : angle < endAngle; angle += step) {\n                    var nextAngle = anticlockwise ? Math.max(angle + step, endAngle)\n                        : Math.min(angle + step, endAngle);\n                    addArc(angle, nextAngle, cx, cy, rx, ry);\n                }\n                break;\n            case CMD.R:\n                x0 = xi = data[i++];\n                y0 = yi = data[i++];\n                x1 = x0 + data[i++];\n                y1 = y0 + data[i++];\n                createNewSubpath(x1, y0);\n                addLine(x1, y0, x1, y1);\n                addLine(x1, y1, x0, y1);\n                addLine(x0, y1, x0, y0);\n                addLine(x0, y0, x1, y0);\n                break;\n            case CMD.Z:\n                currentSubpath && addLine(xi, yi, x0, y0);\n                xi = x0;\n                yi = y0;\n                break;\n        }\n    }\n    if (currentSubpath && currentSubpath.length > 2) {\n        bezierArrayGroups.push(currentSubpath);\n    }\n    return bezierArrayGroups;\n}\nfunction adpativeBezier(x0, y0, x1, y1, x2, y2, x3, y3, out, scale) {\n    if (aroundEqual(x0, x1) && aroundEqual(y0, y1) && aroundEqual(x2, x3) && aroundEqual(y2, y3)) {\n        out.push(x3, y3);\n        return;\n    }\n    var PIXEL_DISTANCE = 2 / scale;\n    var PIXEL_DISTANCE_SQR = PIXEL_DISTANCE * PIXEL_DISTANCE;\n    var dx = x3 - x0;\n    var dy = y3 - y0;\n    var d = Math.sqrt(dx * dx + dy * dy);\n    dx /= d;\n    dy /= d;\n    var dx1 = x1 - x0;\n    var dy1 = y1 - y0;\n    var dx2 = x2 - x3;\n    var dy2 = y2 - y3;\n    var cp1LenSqr = dx1 * dx1 + dy1 * dy1;\n    var cp2LenSqr = dx2 * dx2 + dy2 * dy2;\n    if (cp1LenSqr < PIXEL_DISTANCE_SQR && cp2LenSqr < PIXEL_DISTANCE_SQR) {\n        out.push(x3, y3);\n        return;\n    }\n    var projLen1 = dx * dx1 + dy * dy1;\n    var projLen2 = -dx * dx2 - dy * dy2;\n    var d1Sqr = cp1LenSqr - projLen1 * projLen1;\n    var d2Sqr = cp2LenSqr - projLen2 * projLen2;\n    if (d1Sqr < PIXEL_DISTANCE_SQR && projLen1 >= 0\n        && d2Sqr < PIXEL_DISTANCE_SQR && projLen2 >= 0) {\n        out.push(x3, y3);\n        return;\n    }\n    var tmpSegX = [];\n    var tmpSegY = [];\n    cubicSubdivide(x0, x1, x2, x3, 0.5, tmpSegX);\n    cubicSubdivide(y0, y1, y2, y3, 0.5, tmpSegY);\n    adpativeBezier(tmpSegX[0], tmpSegY[0], tmpSegX[1], tmpSegY[1], tmpSegX[2], tmpSegY[2], tmpSegX[3], tmpSegY[3], out, scale);\n    adpativeBezier(tmpSegX[4], tmpSegY[4], tmpSegX[5], tmpSegY[5], tmpSegX[6], tmpSegY[6], tmpSegX[7], tmpSegY[7], out, scale);\n}\nexport function pathToPolygons(path, scale) {\n    var bezierArrayGroups = pathToBezierCurves(path);\n    var polygons = [];\n    scale = scale || 1;\n    for (var i = 0; i < bezierArrayGroups.length; i++) {\n        var beziers = bezierArrayGroups[i];\n        var polygon = [];\n        var x0 = beziers[0];\n        var y0 = beziers[1];\n        polygon.push(x0, y0);\n        for (var k = 2; k < beziers.length;) {\n            var x1 = beziers[k++];\n            var y1 = beziers[k++];\n            var x2 = beziers[k++];\n            var y2 = beziers[k++];\n            var x3 = beziers[k++];\n            var y3 = beziers[k++];\n            adpativeBezier(x0, y0, x1, y1, x2, y2, x3, y3, polygon, scale);\n            x0 = x3;\n            y0 = y3;\n        }\n        polygons.push(polygon);\n    }\n    return polygons;\n}\n","import { fromPoints } from '../core/bbox.js';\nimport BoundingRect from '../core/BoundingRect.js';\nimport Point from '../core/Point.js';\nimport { map } from '../core/util.js';\nimport Polygon from '../graphic/shape/Polygon.js';\nimport Rect from '../graphic/shape/Rect.js';\nimport Sector from '../graphic/shape/Sector.js';\nimport { pathToPolygons } from './convertPath.js';\nimport { clonePath } from './path.js';\nfunction getDividingGrids(dimSize, rowDim, count) {\n    var rowSize = dimSize[rowDim];\n    var columnSize = dimSize[1 - rowDim];\n    var ratio = Math.abs(rowSize / columnSize);\n    var rowCount = Math.ceil(Math.sqrt(ratio * count));\n    var columnCount = Math.floor(count / rowCount);\n    if (columnCount === 0) {\n        columnCount = 1;\n        rowCount = count;\n    }\n    var grids = [];\n    for (var i = 0; i < rowCount; i++) {\n        grids.push(columnCount);\n    }\n    var currentCount = rowCount * columnCount;\n    var remained = count - currentCount;\n    if (remained > 0) {\n        for (var i = 0; i < remained; i++) {\n            grids[i % rowCount] += 1;\n        }\n    }\n    return grids;\n}\nfunction divideSector(sectorShape, count, outShapes) {\n    var r0 = sectorShape.r0;\n    var r = sectorShape.r;\n    var startAngle = sectorShape.startAngle;\n    var endAngle = sectorShape.endAngle;\n    var angle = Math.abs(endAngle - startAngle);\n    var arcLen = angle * r;\n    var deltaR = r - r0;\n    var isAngleRow = arcLen > Math.abs(deltaR);\n    var grids = getDividingGrids([arcLen, deltaR], isAngleRow ? 0 : 1, count);\n    var rowSize = (isAngleRow ? angle : deltaR) / grids.length;\n    for (var row = 0; row < grids.length; row++) {\n        var columnSize = (isAngleRow ? deltaR : angle) / grids[row];\n        for (var column = 0; column < grids[row]; column++) {\n            var newShape = {};\n            if (isAngleRow) {\n                newShape.startAngle = startAngle + rowSize * row;\n                newShape.endAngle = startAngle + rowSize * (row + 1);\n                newShape.r0 = r0 + columnSize * column;\n                newShape.r = r0 + columnSize * (column + 1);\n            }\n            else {\n                newShape.startAngle = startAngle + columnSize * column;\n                newShape.endAngle = startAngle + columnSize * (column + 1);\n                newShape.r0 = r0 + rowSize * row;\n                newShape.r = r0 + rowSize * (row + 1);\n            }\n            newShape.clockwise = sectorShape.clockwise;\n            newShape.cx = sectorShape.cx;\n            newShape.cy = sectorShape.cy;\n            outShapes.push(newShape);\n        }\n    }\n}\nfunction divideRect(rectShape, count, outShapes) {\n    var width = rectShape.width;\n    var height = rectShape.height;\n    var isHorizontalRow = width > height;\n    var grids = getDividingGrids([width, height], isHorizontalRow ? 0 : 1, count);\n    var rowSizeDim = isHorizontalRow ? 'width' : 'height';\n    var columnSizeDim = isHorizontalRow ? 'height' : 'width';\n    var rowDim = isHorizontalRow ? 'x' : 'y';\n    var columnDim = isHorizontalRow ? 'y' : 'x';\n    var rowSize = rectShape[rowSizeDim] / grids.length;\n    for (var row = 0; row < grids.length; row++) {\n        var columnSize = rectShape[columnSizeDim] / grids[row];\n        for (var column = 0; column < grids[row]; column++) {\n            var newShape = {};\n            newShape[rowDim] = row * rowSize;\n            newShape[columnDim] = column * columnSize;\n            newShape[rowSizeDim] = rowSize;\n            newShape[columnSizeDim] = columnSize;\n            newShape.x += rectShape.x;\n            newShape.y += rectShape.y;\n            outShapes.push(newShape);\n        }\n    }\n}\nfunction crossProduct2d(x1, y1, x2, y2) {\n    return x1 * y2 - x2 * y1;\n}\nfunction lineLineIntersect(a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y) {\n    var mx = a2x - a1x;\n    var my = a2y - a1y;\n    var nx = b2x - b1x;\n    var ny = b2y - b1y;\n    var nmCrossProduct = crossProduct2d(nx, ny, mx, my);\n    if (Math.abs(nmCrossProduct) < 1e-6) {\n        return null;\n    }\n    var b1a1x = a1x - b1x;\n    var b1a1y = a1y - b1y;\n    var p = crossProduct2d(b1a1x, b1a1y, nx, ny) / nmCrossProduct;\n    if (p < 0 || p > 1) {\n        return null;\n    }\n    return new Point(p * mx + a1x, p * my + a1y);\n}\nfunction projPtOnLine(pt, lineA, lineB) {\n    var dir = new Point();\n    Point.sub(dir, lineB, lineA);\n    dir.normalize();\n    var dir2 = new Point();\n    Point.sub(dir2, pt, lineA);\n    var len = dir2.dot(dir);\n    return len;\n}\nfunction addToPoly(poly, pt) {\n    var last = poly[poly.length - 1];\n    if (last && last[0] === pt[0] && last[1] === pt[1]) {\n        return;\n    }\n    poly.push(pt);\n}\nfunction splitPolygonByLine(points, lineA, lineB) {\n    var len = points.length;\n    var intersections = [];\n    for (var i = 0; i < len; i++) {\n        var p0 = points[i];\n        var p1 = points[(i + 1) % len];\n        var intersectionPt = lineLineIntersect(p0[0], p0[1], p1[0], p1[1], lineA.x, lineA.y, lineB.x, lineB.y);\n        if (intersectionPt) {\n            intersections.push({\n                projPt: projPtOnLine(intersectionPt, lineA, lineB),\n                pt: intersectionPt,\n                idx: i\n            });\n        }\n    }\n    if (intersections.length < 2) {\n        return [{ points: points }, { points: points }];\n    }\n    intersections.sort(function (a, b) {\n        return a.projPt - b.projPt;\n    });\n    var splitPt0 = intersections[0];\n    var splitPt1 = intersections[intersections.length - 1];\n    if (splitPt1.idx < splitPt0.idx) {\n        var tmp = splitPt0;\n        splitPt0 = splitPt1;\n        splitPt1 = tmp;\n    }\n    var splitPt0Arr = [splitPt0.pt.x, splitPt0.pt.y];\n    var splitPt1Arr = [splitPt1.pt.x, splitPt1.pt.y];\n    var newPolyA = [splitPt0Arr];\n    var newPolyB = [splitPt1Arr];\n    for (var i = splitPt0.idx + 1; i <= splitPt1.idx; i++) {\n        addToPoly(newPolyA, points[i].slice());\n    }\n    addToPoly(newPolyA, splitPt1Arr);\n    addToPoly(newPolyA, splitPt0Arr);\n    for (var i = splitPt1.idx + 1; i <= splitPt0.idx + len; i++) {\n        addToPoly(newPolyB, points[i % len].slice());\n    }\n    addToPoly(newPolyB, splitPt0Arr);\n    addToPoly(newPolyB, splitPt1Arr);\n    return [{\n            points: newPolyA\n        }, {\n            points: newPolyB\n        }];\n}\nfunction binaryDividePolygon(polygonShape) {\n    var points = polygonShape.points;\n    var min = [];\n    var max = [];\n    fromPoints(points, min, max);\n    var boundingRect = new BoundingRect(min[0], min[1], max[0] - min[0], max[1] - min[1]);\n    var width = boundingRect.width;\n    var height = boundingRect.height;\n    var x = boundingRect.x;\n    var y = boundingRect.y;\n    var pt0 = new Point();\n    var pt1 = new Point();\n    if (width > height) {\n        pt0.x = pt1.x = x + width / 2;\n        pt0.y = y;\n        pt1.y = y + height;\n    }\n    else {\n        pt0.y = pt1.y = y + height / 2;\n        pt0.x = x;\n        pt1.x = x + width;\n    }\n    return splitPolygonByLine(points, pt0, pt1);\n}\nfunction binaryDivideRecursive(divider, shape, count, out) {\n    if (count === 1) {\n        out.push(shape);\n    }\n    else {\n        var mid = Math.floor(count / 2);\n        var sub = divider(shape);\n        binaryDivideRecursive(divider, sub[0], mid, out);\n        binaryDivideRecursive(divider, sub[1], count - mid, out);\n    }\n    return out;\n}\nexport function clone(path, count) {\n    var paths = [];\n    for (var i = 0; i < count; i++) {\n        paths.push(clonePath(path));\n    }\n    return paths;\n}\nfunction copyPathProps(source, target) {\n    target.setStyle(source.style);\n    target.z = source.z;\n    target.z2 = source.z2;\n    target.zlevel = source.zlevel;\n}\nfunction polygonConvert(points) {\n    var out = [];\n    for (var i = 0; i < points.length;) {\n        out.push([points[i++], points[i++]]);\n    }\n    return out;\n}\nexport function split(path, count) {\n    var outShapes = [];\n    var shape = path.shape;\n    var OutShapeCtor;\n    switch (path.type) {\n        case 'rect':\n            divideRect(shape, count, outShapes);\n            OutShapeCtor = Rect;\n            break;\n        case 'sector':\n            divideSector(shape, count, outShapes);\n            OutShapeCtor = Sector;\n            break;\n        case 'circle':\n            divideSector({\n                r0: 0, r: shape.r, startAngle: 0, endAngle: Math.PI * 2,\n                cx: shape.cx, cy: shape.cy\n            }, count, outShapes);\n            OutShapeCtor = Sector;\n            break;\n        default:\n            var m = path.getComputedTransform();\n            var scale = m ? Math.sqrt(Math.max(m[0] * m[0] + m[1] * m[1], m[2] * m[2] + m[3] * m[3])) : 1;\n            var polygons = map(pathToPolygons(path.getUpdatedPathProxy(), scale), function (poly) { return polygonConvert(poly); });\n            var polygonCount = polygons.length;\n            if (polygonCount === 0) {\n                binaryDivideRecursive(binaryDividePolygon, {\n                    points: polygons[0]\n                }, count, outShapes);\n            }\n            else if (polygonCount === count) {\n                for (var i = 0; i < polygonCount; i++) {\n                    outShapes.push({\n                        points: polygons[i]\n                    });\n                }\n            }\n            else {\n                var totalArea_1 = 0;\n                var items = map(polygons, function (poly) {\n                    var min = [];\n                    var max = [];\n                    fromPoints(poly, min, max);\n                    var area = (max[1] - min[1]) * (max[0] - min[0]);\n                    totalArea_1 += area;\n                    return { poly: poly, area: area };\n                });\n                items.sort(function (a, b) { return b.area - a.area; });\n                var left = count;\n                for (var i = 0; i < polygonCount; i++) {\n                    var item = items[i];\n                    if (left <= 0) {\n                        break;\n                    }\n                    var selfCount = i === polygonCount - 1\n                        ? left\n                        : Math.ceil(item.area / totalArea_1 * count);\n                    if (selfCount < 0) {\n                        continue;\n                    }\n                    binaryDivideRecursive(binaryDividePolygon, {\n                        points: item.poly\n                    }, selfCount, outShapes);\n                    left -= selfCount;\n                }\n                ;\n            }\n            OutShapeCtor = Polygon;\n            break;\n    }\n    if (!OutShapeCtor) {\n        return clone(path, count);\n    }\n    var out = [];\n    for (var i = 0; i < outShapes.length; i++) {\n        var subPath = new OutShapeCtor();\n        subPath.setShape(outShapes[i]);\n        copyPathProps(path, subPath);\n        out.push(subPath);\n    }\n    return out;\n}\n","import { cubicSubdivide } from '../core/curve.js';\nimport Path from '../graphic/Path.js';\nimport { defaults, map } from '../core/util.js';\nimport { lerp } from '../core/vector.js';\nimport { clonePath } from './path.js';\nimport Transformable from '../core/Transformable.js';\nimport { split } from './dividePath.js';\nimport { pathToBezierCurves } from './convertPath.js';\nfunction alignSubpath(subpath1, subpath2) {\n    var len1 = subpath1.length;\n    var len2 = subpath2.length;\n    if (len1 === len2) {\n        return [subpath1, subpath2];\n    }\n    var tmpSegX = [];\n    var tmpSegY = [];\n    var shorterPath = len1 < len2 ? subpath1 : subpath2;\n    var shorterLen = Math.min(len1, len2);\n    var diff = Math.abs(len2 - len1) / 6;\n    var shorterBezierCount = (shorterLen - 2) / 6;\n    var eachCurveSubDivCount = Math.ceil(diff / shorterBezierCount) + 1;\n    var newSubpath = [shorterPath[0], shorterPath[1]];\n    var remained = diff;\n    for (var i = 2; i < shorterLen;) {\n        var x0 = shorterPath[i - 2];\n        var y0 = shorterPath[i - 1];\n        var x1 = shorterPath[i++];\n        var y1 = shorterPath[i++];\n        var x2 = shorterPath[i++];\n        var y2 = shorterPath[i++];\n        var x3 = shorterPath[i++];\n        var y3 = shorterPath[i++];\n        if (remained <= 0) {\n            newSubpath.push(x1, y1, x2, y2, x3, y3);\n            continue;\n        }\n        var actualSubDivCount = Math.min(remained, eachCurveSubDivCount - 1) + 1;\n        for (var k = 1; k <= actualSubDivCount; k++) {\n            var p = k / actualSubDivCount;\n            cubicSubdivide(x0, x1, x2, x3, p, tmpSegX);\n            cubicSubdivide(y0, y1, y2, y3, p, tmpSegY);\n            x0 = tmpSegX[3];\n            y0 = tmpSegY[3];\n            newSubpath.push(tmpSegX[1], tmpSegY[1], tmpSegX[2], tmpSegY[2], x0, y0);\n            x1 = tmpSegX[5];\n            y1 = tmpSegY[5];\n            x2 = tmpSegX[6];\n            y2 = tmpSegY[6];\n        }\n        remained -= actualSubDivCount - 1;\n    }\n    return shorterPath === subpath1 ? [newSubpath, subpath2] : [subpath1, newSubpath];\n}\nfunction createSubpath(lastSubpathSubpath, otherSubpath) {\n    var len = lastSubpathSubpath.length;\n    var lastX = lastSubpathSubpath[len - 2];\n    var lastY = lastSubpathSubpath[len - 1];\n    var newSubpath = [];\n    for (var i = 0; i < otherSubpath.length;) {\n        newSubpath[i++] = lastX;\n        newSubpath[i++] = lastY;\n    }\n    return newSubpath;\n}\nexport function alignBezierCurves(array1, array2) {\n    var _a;\n    var lastSubpath1;\n    var lastSubpath2;\n    var newArray1 = [];\n    var newArray2 = [];\n    for (var i = 0; i < Math.max(array1.length, array2.length); i++) {\n        var subpath1 = array1[i];\n        var subpath2 = array2[i];\n        var newSubpath1 = void 0;\n        var newSubpath2 = void 0;\n        if (!subpath1) {\n            newSubpath1 = createSubpath(lastSubpath1 || subpath2, subpath2);\n            newSubpath2 = subpath2;\n        }\n        else if (!subpath2) {\n            newSubpath2 = createSubpath(lastSubpath2 || subpath1, subpath1);\n            newSubpath1 = subpath1;\n        }\n        else {\n            _a = alignSubpath(subpath1, subpath2), newSubpath1 = _a[0], newSubpath2 = _a[1];\n            lastSubpath1 = newSubpath1;\n            lastSubpath2 = newSubpath2;\n        }\n        newArray1.push(newSubpath1);\n        newArray2.push(newSubpath2);\n    }\n    return [newArray1, newArray2];\n}\nexport function centroid(array) {\n    var signedArea = 0;\n    var cx = 0;\n    var cy = 0;\n    var len = array.length;\n    for (var i = 0, j = len - 2; i < len; j = i, i += 2) {\n        var x0 = array[j];\n        var y0 = array[j + 1];\n        var x1 = array[i];\n        var y1 = array[i + 1];\n        var a = x0 * y1 - x1 * y0;\n        signedArea += a;\n        cx += (x0 + x1) * a;\n        cy += (y0 + y1) * a;\n    }\n    if (signedArea === 0) {\n        return [array[0] || 0, array[1] || 0];\n    }\n    return [cx / signedArea / 3, cy / signedArea / 3, signedArea];\n}\nfunction findBestRingOffset(fromSubBeziers, toSubBeziers, fromCp, toCp) {\n    var bezierCount = (fromSubBeziers.length - 2) / 6;\n    var bestScore = Infinity;\n    var bestOffset = 0;\n    var len = fromSubBeziers.length;\n    var len2 = len - 2;\n    for (var offset = 0; offset < bezierCount; offset++) {\n        var cursorOffset = offset * 6;\n        var score = 0;\n        for (var k = 0; k < len; k += 2) {\n            var idx = k === 0 ? cursorOffset : ((cursorOffset + k - 2) % len2 + 2);\n            var x0 = fromSubBeziers[idx] - fromCp[0];\n            var y0 = fromSubBeziers[idx + 1] - fromCp[1];\n            var x1 = toSubBeziers[k] - toCp[0];\n            var y1 = toSubBeziers[k + 1] - toCp[1];\n            var dx = x1 - x0;\n            var dy = y1 - y0;\n            score += dx * dx + dy * dy;\n        }\n        if (score < bestScore) {\n            bestScore = score;\n            bestOffset = offset;\n        }\n    }\n    return bestOffset;\n}\nfunction reverse(array) {\n    var newArr = [];\n    var len = array.length;\n    for (var i = 0; i < len; i += 2) {\n        newArr[i] = array[len - i - 2];\n        newArr[i + 1] = array[len - i - 1];\n    }\n    return newArr;\n}\nfunction findBestMorphingRotation(fromArr, toArr, searchAngleIteration, searchAngleRange) {\n    var result = [];\n    var fromNeedsReverse;\n    for (var i = 0; i < fromArr.length; i++) {\n        var fromSubpathBezier = fromArr[i];\n        var toSubpathBezier = toArr[i];\n        var fromCp = centroid(fromSubpathBezier);\n        var toCp = centroid(toSubpathBezier);\n        if (fromNeedsReverse == null) {\n            fromNeedsReverse = fromCp[2] < 0 !== toCp[2] < 0;\n        }\n        var newFromSubpathBezier = [];\n        var newToSubpathBezier = [];\n        var bestAngle = 0;\n        var bestScore = Infinity;\n        var tmpArr = [];\n        var len = fromSubpathBezier.length;\n        if (fromNeedsReverse) {\n            fromSubpathBezier = reverse(fromSubpathBezier);\n        }\n        var offset = findBestRingOffset(fromSubpathBezier, toSubpathBezier, fromCp, toCp) * 6;\n        var len2 = len - 2;\n        for (var k = 0; k < len2; k += 2) {\n            var idx = (offset + k) % len2 + 2;\n            newFromSubpathBezier[k + 2] = fromSubpathBezier[idx] - fromCp[0];\n            newFromSubpathBezier[k + 3] = fromSubpathBezier[idx + 1] - fromCp[1];\n        }\n        newFromSubpathBezier[0] = fromSubpathBezier[offset] - fromCp[0];\n        newFromSubpathBezier[1] = fromSubpathBezier[offset + 1] - fromCp[1];\n        if (searchAngleIteration > 0) {\n            var step = searchAngleRange / searchAngleIteration;\n            for (var angle = -searchAngleRange / 2; angle <= searchAngleRange / 2; angle += step) {\n                var sa = Math.sin(angle);\n                var ca = Math.cos(angle);\n                var score = 0;\n                for (var k = 0; k < fromSubpathBezier.length; k += 2) {\n                    var x0 = newFromSubpathBezier[k];\n                    var y0 = newFromSubpathBezier[k + 1];\n                    var x1 = toSubpathBezier[k] - toCp[0];\n                    var y1 = toSubpathBezier[k + 1] - toCp[1];\n                    var newX1 = x1 * ca - y1 * sa;\n                    var newY1 = x1 * sa + y1 * ca;\n                    tmpArr[k] = newX1;\n                    tmpArr[k + 1] = newY1;\n                    var dx = newX1 - x0;\n                    var dy = newY1 - y0;\n                    score += dx * dx + dy * dy;\n                }\n                if (score < bestScore) {\n                    bestScore = score;\n                    bestAngle = angle;\n                    for (var m = 0; m < tmpArr.length; m++) {\n                        newToSubpathBezier[m] = tmpArr[m];\n                    }\n                }\n            }\n        }\n        else {\n            for (var i_1 = 0; i_1 < len; i_1 += 2) {\n                newToSubpathBezier[i_1] = toSubpathBezier[i_1] - toCp[0];\n                newToSubpathBezier[i_1 + 1] = toSubpathBezier[i_1 + 1] - toCp[1];\n            }\n        }\n        result.push({\n            from: newFromSubpathBezier,\n            to: newToSubpathBezier,\n            fromCp: fromCp,\n            toCp: toCp,\n            rotation: -bestAngle\n        });\n    }\n    return result;\n}\nexport function isCombineMorphing(path) {\n    return path.__isCombineMorphing;\n}\nexport function isMorphing(el) {\n    return el.__morphT >= 0;\n}\nvar SAVED_METHOD_PREFIX = '__mOriginal_';\nfunction saveAndModifyMethod(obj, methodName, modifiers) {\n    var savedMethodName = SAVED_METHOD_PREFIX + methodName;\n    var originalMethod = obj[savedMethodName] || obj[methodName];\n    if (!obj[savedMethodName]) {\n        obj[savedMethodName] = obj[methodName];\n    }\n    var replace = modifiers.replace;\n    var after = modifiers.after;\n    var before = modifiers.before;\n    obj[methodName] = function () {\n        var args = arguments;\n        var res;\n        before && before.apply(this, args);\n        if (replace) {\n            res = replace.apply(this, args);\n        }\n        else {\n            res = originalMethod.apply(this, args);\n        }\n        after && after.apply(this, args);\n        return res;\n    };\n}\nfunction restoreMethod(obj, methodName) {\n    var savedMethodName = SAVED_METHOD_PREFIX + methodName;\n    if (obj[savedMethodName]) {\n        obj[methodName] = obj[savedMethodName];\n        obj[savedMethodName] = null;\n    }\n}\nfunction applyTransformOnBeziers(bezierCurves, mm) {\n    for (var i = 0; i < bezierCurves.length; i++) {\n        var subBeziers = bezierCurves[i];\n        for (var k = 0; k < subBeziers.length;) {\n            var x = subBeziers[k];\n            var y = subBeziers[k + 1];\n            subBeziers[k++] = mm[0] * x + mm[2] * y + mm[4];\n            subBeziers[k++] = mm[1] * x + mm[3] * y + mm[5];\n        }\n    }\n}\nfunction prepareMorphPath(fromPath, toPath) {\n    var fromPathProxy = fromPath.getUpdatedPathProxy();\n    var toPathProxy = toPath.getUpdatedPathProxy();\n    var _a = alignBezierCurves(pathToBezierCurves(fromPathProxy), pathToBezierCurves(toPathProxy)), fromBezierCurves = _a[0], toBezierCurves = _a[1];\n    var fromPathTransform = fromPath.getComputedTransform();\n    var toPathTransform = toPath.getComputedTransform();\n    function updateIdentityTransform() {\n        this.transform = null;\n    }\n    fromPathTransform && applyTransformOnBeziers(fromBezierCurves, fromPathTransform);\n    toPathTransform && applyTransformOnBeziers(toBezierCurves, toPathTransform);\n    saveAndModifyMethod(toPath, 'updateTransform', { replace: updateIdentityTransform });\n    toPath.transform = null;\n    var morphingData = findBestMorphingRotation(fromBezierCurves, toBezierCurves, 10, Math.PI);\n    var tmpArr = [];\n    saveAndModifyMethod(toPath, 'buildPath', { replace: function (path) {\n            var t = toPath.__morphT;\n            var onet = 1 - t;\n            var newCp = [];\n            for (var i = 0; i < morphingData.length; i++) {\n                var item = morphingData[i];\n                var from = item.from;\n                var to = item.to;\n                var angle = item.rotation * t;\n                var fromCp = item.fromCp;\n                var toCp = item.toCp;\n                var sa = Math.sin(angle);\n                var ca = Math.cos(angle);\n                lerp(newCp, fromCp, toCp, t);\n                for (var m = 0; m < from.length; m += 2) {\n                    var x0_1 = from[m];\n                    var y0_1 = from[m + 1];\n                    var x1 = to[m];\n                    var y1 = to[m + 1];\n                    var x = x0_1 * onet + x1 * t;\n                    var y = y0_1 * onet + y1 * t;\n                    tmpArr[m] = (x * ca - y * sa) + newCp[0];\n                    tmpArr[m + 1] = (x * sa + y * ca) + newCp[1];\n                }\n                var x0 = tmpArr[0];\n                var y0 = tmpArr[1];\n                path.moveTo(x0, y0);\n                for (var m = 2; m < from.length;) {\n                    var x1 = tmpArr[m++];\n                    var y1 = tmpArr[m++];\n                    var x2 = tmpArr[m++];\n                    var y2 = tmpArr[m++];\n                    var x3 = tmpArr[m++];\n                    var y3 = tmpArr[m++];\n                    if (x0 === x1 && y0 === y1 && x2 === x3 && y2 === y3) {\n                        path.lineTo(x3, y3);\n                    }\n                    else {\n                        path.bezierCurveTo(x1, y1, x2, y2, x3, y3);\n                    }\n                    x0 = x3;\n                    y0 = y3;\n                }\n            }\n        } });\n}\nexport function morphPath(fromPath, toPath, animationOpts) {\n    if (!fromPath || !toPath) {\n        return toPath;\n    }\n    var oldDone = animationOpts.done;\n    var oldDuring = animationOpts.during;\n    prepareMorphPath(fromPath, toPath);\n    toPath.__morphT = 0;\n    function restoreToPath() {\n        restoreMethod(toPath, 'buildPath');\n        restoreMethod(toPath, 'updateTransform');\n        toPath.__morphT = -1;\n        toPath.createPathProxy();\n        toPath.dirtyShape();\n    }\n    toPath.animateTo({\n        __morphT: 1\n    }, defaults({\n        during: function (p) {\n            toPath.dirtyShape();\n            oldDuring && oldDuring(p);\n        },\n        done: function () {\n            restoreToPath();\n            oldDone && oldDone();\n        }\n    }, animationOpts));\n    return toPath;\n}\nfunction hilbert(x, y, minX, minY, maxX, maxY) {\n    var bits = 16;\n    x = (maxX === minX) ? 0 : Math.round(32767 * (x - minX) / (maxX - minX));\n    y = (maxY === minY) ? 0 : Math.round(32767 * (y - minY) / (maxY - minY));\n    var d = 0;\n    var tmp;\n    for (var s = (1 << bits) / 2; s > 0; s /= 2) {\n        var rx = 0;\n        var ry = 0;\n        if ((x & s) > 0) {\n            rx = 1;\n        }\n        if ((y & s) > 0) {\n            ry = 1;\n        }\n        d += s * s * ((3 * rx) ^ ry);\n        if (ry === 0) {\n            if (rx === 1) {\n                x = s - 1 - x;\n                y = s - 1 - y;\n            }\n            tmp = x;\n            x = y;\n            y = tmp;\n        }\n    }\n    return d;\n}\nfunction sortPaths(pathList) {\n    var xMin = Infinity;\n    var yMin = Infinity;\n    var xMax = -Infinity;\n    var yMax = -Infinity;\n    var cps = map(pathList, function (path) {\n        var rect = path.getBoundingRect();\n        var m = path.getComputedTransform();\n        var x = rect.x + rect.width / 2 + (m ? m[4] : 0);\n        var y = rect.y + rect.height / 2 + (m ? m[5] : 0);\n        xMin = Math.min(x, xMin);\n        yMin = Math.min(y, yMin);\n        xMax = Math.max(x, xMax);\n        yMax = Math.max(y, yMax);\n        return [x, y];\n    });\n    var items = map(cps, function (cp, idx) {\n        return {\n            cp: cp,\n            z: hilbert(cp[0], cp[1], xMin, yMin, xMax, yMax),\n            path: pathList[idx]\n        };\n    });\n    return items.sort(function (a, b) { return a.z - b.z; }).map(function (item) { return item.path; });\n}\n;\nfunction defaultDividePath(param) {\n    return split(param.path, param.count);\n}\nfunction createEmptyReturn() {\n    return {\n        fromIndividuals: [],\n        toIndividuals: [],\n        count: 0\n    };\n}\nexport function combineMorph(fromList, toPath, animationOpts) {\n    var fromPathList = [];\n    function addFromPath(fromList) {\n        for (var i = 0; i < fromList.length; i++) {\n            var from = fromList[i];\n            if (isCombineMorphing(from)) {\n                addFromPath(from.childrenRef());\n            }\n            else if (from instanceof Path) {\n                fromPathList.push(from);\n            }\n        }\n    }\n    addFromPath(fromList);\n    var separateCount = fromPathList.length;\n    if (!separateCount) {\n        return createEmptyReturn();\n    }\n    var dividePath = animationOpts.dividePath || defaultDividePath;\n    var toSubPathList = dividePath({\n        path: toPath, count: separateCount\n    });\n    if (toSubPathList.length !== separateCount) {\n        console.error('Invalid morphing: unmatched splitted path');\n        return createEmptyReturn();\n    }\n    fromPathList = sortPaths(fromPathList);\n    toSubPathList = sortPaths(toSubPathList);\n    var oldDone = animationOpts.done;\n    var oldDuring = animationOpts.during;\n    var individualDelay = animationOpts.individualDelay;\n    var identityTransform = new Transformable();\n    for (var i = 0; i < separateCount; i++) {\n        var from = fromPathList[i];\n        var to = toSubPathList[i];\n        to.parent = toPath;\n        to.copyTransform(identityTransform);\n        if (!individualDelay) {\n            prepareMorphPath(from, to);\n        }\n    }\n    toPath.__isCombineMorphing = true;\n    toPath.childrenRef = function () {\n        return toSubPathList;\n    };\n    function addToSubPathListToZr(zr) {\n        for (var i = 0; i < toSubPathList.length; i++) {\n            toSubPathList[i].addSelfToZr(zr);\n        }\n    }\n    saveAndModifyMethod(toPath, 'addSelfToZr', {\n        after: function (zr) {\n            addToSubPathListToZr(zr);\n        }\n    });\n    saveAndModifyMethod(toPath, 'removeSelfFromZr', {\n        after: function (zr) {\n            for (var i = 0; i < toSubPathList.length; i++) {\n                toSubPathList[i].removeSelfFromZr(zr);\n            }\n        }\n    });\n    function restoreToPath() {\n        toPath.__isCombineMorphing = false;\n        toPath.__morphT = -1;\n        toPath.childrenRef = null;\n        restoreMethod(toPath, 'addSelfToZr');\n        restoreMethod(toPath, 'removeSelfFromZr');\n    }\n    var toLen = toSubPathList.length;\n    if (individualDelay) {\n        var animating_1 = toLen;\n        var eachDone = function () {\n            animating_1--;\n            if (animating_1 === 0) {\n                restoreToPath();\n                oldDone && oldDone();\n            }\n        };\n        for (var i = 0; i < toLen; i++) {\n            var indivdualAnimationOpts = individualDelay ? defaults({\n                delay: (animationOpts.delay || 0) + individualDelay(i, toLen, fromPathList[i], toSubPathList[i]),\n                done: eachDone\n            }, animationOpts) : animationOpts;\n            morphPath(fromPathList[i], toSubPathList[i], indivdualAnimationOpts);\n        }\n    }\n    else {\n        toPath.__morphT = 0;\n        toPath.animateTo({\n            __morphT: 1\n        }, defaults({\n            during: function (p) {\n                for (var i = 0; i < toLen; i++) {\n                    var child = toSubPathList[i];\n                    child.__morphT = toPath.__morphT;\n                    child.dirtyShape();\n                }\n                oldDuring && oldDuring(p);\n            },\n            done: function () {\n                restoreToPath();\n                for (var i = 0; i < fromList.length; i++) {\n                    restoreMethod(fromList[i], 'updateTransform');\n                }\n                oldDone && oldDone();\n            }\n        }, animationOpts));\n    }\n    if (toPath.__zr) {\n        addToSubPathListToZr(toPath.__zr);\n    }\n    return {\n        fromIndividuals: fromPathList,\n        toIndividuals: toSubPathList,\n        count: toLen\n    };\n}\nexport function separateMorph(fromPath, toPathList, animationOpts) {\n    var toLen = toPathList.length;\n    var fromPathList = [];\n    var dividePath = animationOpts.dividePath || defaultDividePath;\n    function addFromPath(fromList) {\n        for (var i = 0; i < fromList.length; i++) {\n            var from = fromList[i];\n            if (isCombineMorphing(from)) {\n                addFromPath(from.childrenRef());\n            }\n            else if (from instanceof Path) {\n                fromPathList.push(from);\n            }\n        }\n    }\n    if (isCombineMorphing(fromPath)) {\n        addFromPath(fromPath.childrenRef());\n        var fromLen = fromPathList.length;\n        if (fromLen < toLen) {\n            var k = 0;\n            for (var i = fromLen; i < toLen; i++) {\n                fromPathList.push(clonePath(fromPathList[k++ % fromLen]));\n            }\n        }\n        fromPathList.length = toLen;\n    }\n    else {\n        fromPathList = dividePath({ path: fromPath, count: toLen });\n        var fromPathTransform = fromPath.getComputedTransform();\n        for (var i = 0; i < fromPathList.length; i++) {\n            fromPathList[i].setLocalTransform(fromPathTransform);\n        }\n        if (fromPathList.length !== toLen) {\n            console.error('Invalid morphing: unmatched splitted path');\n            return createEmptyReturn();\n        }\n    }\n    fromPathList = sortPaths(fromPathList);\n    toPathList = sortPaths(toPathList);\n    var individualDelay = animationOpts.individualDelay;\n    for (var i = 0; i < toLen; i++) {\n        var indivdualAnimationOpts = individualDelay ? defaults({\n            delay: (animationOpts.delay || 0) + individualDelay(i, toLen, fromPathList[i], toPathList[i])\n        }, animationOpts) : animationOpts;\n        morphPath(fromPathList[i], toPathList[i], indivdualAnimationOpts);\n    }\n    return {\n        fromIndividuals: fromPathList,\n        toIndividuals: toPathList,\n        count: toPathList.length\n    };\n}\nexport { split as defaultDividePath };\n","\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { separateMorph, combineMorph, morphPath, isCombineMorphing } from 'zrender/lib/tool/morphPath.js';\nimport { Path } from '../util/graphic.js';\nimport { defaults, isArray } from 'zrender/lib/core/util.js';\nimport { getAnimationConfig } from './basicTransition.js';\nimport { clonePath } from 'zrender/lib/tool/path.js';\nfunction isMultiple(elements) {\n  return isArray(elements[0]);\n}\nfunction prepareMorphBatches(one, many) {\n  var batches = [];\n  var batchCount = one.length;\n  for (var i = 0; i < batchCount; i++) {\n    batches.push({\n      one: one[i],\n      many: []\n    });\n  }\n  for (var i = 0; i < many.length; i++) {\n    var len = many[i].length;\n    var k = void 0;\n    for (k = 0; k < len; k++) {\n      batches[k % batchCount].many.push(many[i][k]);\n    }\n  }\n  var off = 0;\n  // If one has more paths than each one of many. average them.\n  for (var i = batchCount - 1; i >= 0; i--) {\n    if (!batches[i].many.length) {\n      var moveFrom = batches[off].many;\n      if (moveFrom.length <= 1) {\n        // Not enough\n        // Start from the first one.\n        if (off) {\n          off = 0;\n        } else {\n          return batches;\n        }\n      }\n      var len = moveFrom.length;\n      var mid = Math.ceil(len / 2);\n      batches[i].many = moveFrom.slice(mid, len);\n      batches[off].many = moveFrom.slice(0, mid);\n      off++;\n    }\n  }\n  return batches;\n}\nvar pathDividers = {\n  clone: function (params) {\n    var ret = [];\n    // Fitting the alpha\n    var approxOpacity = 1 - Math.pow(1 - params.path.style.opacity, 1 / params.count);\n    for (var i = 0; i < params.count; i++) {\n      var cloned = clonePath(params.path);\n      cloned.setStyle('opacity', approxOpacity);\n      ret.push(cloned);\n    }\n    return ret;\n  },\n  // Use the default divider\n  split: null\n};\nexport function applyMorphAnimation(from, to, divideShape, seriesModel, dataIndex, animateOtherProps) {\n  if (!from.length || !to.length) {\n    return;\n  }\n  var updateAnimationCfg = getAnimationConfig('update', seriesModel, dataIndex);\n  if (!(updateAnimationCfg && updateAnimationCfg.duration > 0)) {\n    return;\n  }\n  var animationDelay = seriesModel.getModel('universalTransition').get('delay');\n  var animationCfg = Object.assign({\n    // Need to setToFinal so the further calculation based on the style can be correct.\n    // Like emphasis color.\n    setToFinal: true\n  }, updateAnimationCfg);\n  var many;\n  var one;\n  if (isMultiple(from)) {\n    // manyToOne\n    many = from;\n    one = to;\n  }\n  if (isMultiple(to)) {\n    // oneToMany\n    many = to;\n    one = from;\n  }\n  function morphOneBatch(batch, fromIsMany, animateIndex, animateCount, forceManyOne) {\n    var batchMany = batch.many;\n    var batchOne = batch.one;\n    if (batchMany.length === 1 && !forceManyOne) {\n      // Is one to one\n      var batchFrom = fromIsMany ? batchMany[0] : batchOne;\n      var batchTo = fromIsMany ? batchOne : batchMany[0];\n      if (isCombineMorphing(batchFrom)) {\n        // Keep doing combine animation.\n        morphOneBatch({\n          many: [batchFrom],\n          one: batchTo\n        }, true, animateIndex, animateCount, true);\n      } else {\n        var individualAnimationCfg = animationDelay ? defaults({\n          delay: animationDelay(animateIndex, animateCount)\n        }, animationCfg) : animationCfg;\n        morphPath(batchFrom, batchTo, individualAnimationCfg);\n        animateOtherProps(batchFrom, batchTo, batchFrom, batchTo, individualAnimationCfg);\n      }\n    } else {\n      var separateAnimationCfg = defaults({\n        dividePath: pathDividers[divideShape],\n        individualDelay: animationDelay && function (idx, count, fromPath, toPath) {\n          return animationDelay(idx + animateIndex, animateCount);\n        }\n      }, animationCfg);\n      var _a = fromIsMany ? combineMorph(batchMany, batchOne, separateAnimationCfg) : separateMorph(batchOne, batchMany, separateAnimationCfg),\n        fromIndividuals = _a.fromIndividuals,\n        toIndividuals = _a.toIndividuals;\n      var count = fromIndividuals.length;\n      for (var k = 0; k < count; k++) {\n        var individualAnimationCfg = animationDelay ? defaults({\n          delay: animationDelay(k, count)\n        }, animationCfg) : animationCfg;\n        animateOtherProps(fromIndividuals[k], toIndividuals[k], fromIsMany ? batchMany[k] : batch.one, fromIsMany ? batch.one : batchMany[k], individualAnimationCfg);\n      }\n    }\n  }\n  var fromIsMany = many ? many === from\n  // Is one to one. If the path number not match. also needs do merge and separate morphing.\n  : from.length > to.length;\n  var morphBatches = many ? prepareMorphBatches(one, many) : prepareMorphBatches(fromIsMany ? to : from, [fromIsMany ? from : to]);\n  var animateCount = 0;\n  for (var i = 0; i < morphBatches.length; i++) {\n    animateCount += morphBatches[i].many.length;\n  }\n  var animateIndex = 0;\n  for (var i = 0; i < morphBatches.length; i++) {\n    morphOneBatch(morphBatches[i], fromIsMany, animateIndex, animateCount);\n    animateIndex += morphBatches[i].many.length;\n  }\n}\nexport function getPathList(elements) {\n  if (!elements) {\n    return [];\n  }\n  if (isArray(elements)) {\n    var pathList_1 = [];\n    for (var i = 0; i < elements.length; i++) {\n      pathList_1.push(getPathList(elements[i]));\n    }\n    return pathList_1;\n  }\n  var pathList = [];\n  elements.traverse(function (el) {\n    if (el instanceof Path && !el.disableMorphing && !el.invisible && !el.ignore) {\n      pathList.push(el);\n    }\n  });\n  return pathList;\n}","\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// Universal transitions that can animate between any shapes(series) and any properties in any amounts.\nimport { SERIES_UNIVERSAL_TRANSITION_PROP } from '../model/Series.js';\nimport { createHashMap, each, map, filter, isArray, extend } from 'zrender/lib/core/util.js';\nimport { applyMorphAnimation, getPathList } from './morphTransitionHelper.js';\nimport Path from 'zrender/lib/graphic/Path.js';\nimport { initProps } from '../util/graphic.js';\nimport DataDiffer from '../data/DataDiffer.js';\nimport { makeInner, normalizeToArray } from '../util/model.js';\nimport { warn } from '../util/log.js';\nimport { getAnimationConfig, getOldStyle } from './basicTransition.js';\nimport Displayable from 'zrender/lib/graphic/Displayable.js';\nvar DATA_COUNT_THRESHOLD = 1e4;\nvar TRANSITION_NONE = 0;\nvar TRANSITION_P2C = 1;\nvar TRANSITION_C2P = 2;\n;\nvar getUniversalTransitionGlobalStore = makeInner();\nfunction getDimension(data, visualDimension) {\n  var dimensions = data.dimensions;\n  for (var i = 0; i < dimensions.length; i++) {\n    var dimInfo = data.getDimensionInfo(dimensions[i]);\n    if (dimInfo && dimInfo.otherDims[visualDimension] === 0) {\n      return dimensions[i];\n    }\n  }\n}\n// get value by dimension. (only get value of itemGroupId or childGroupId, so convert it to string)\nfunction getValueByDimension(data, dataIndex, dimension) {\n  var dimInfo = data.getDimensionInfo(dimension);\n  var dimOrdinalMeta = dimInfo && dimInfo.ordinalMeta;\n  if (dimInfo) {\n    var value = data.get(dimInfo.name, dataIndex);\n    if (dimOrdinalMeta) {\n      return dimOrdinalMeta.categories[value] || value + '';\n    }\n    return value + '';\n  }\n}\nfunction getGroupId(data, dataIndex, dataGroupId, isChild) {\n  // try to get groupId from encode\n  var visualDimension = isChild ? 'itemChildGroupId' : 'itemGroupId';\n  var groupIdDim = getDimension(data, visualDimension);\n  if (groupIdDim) {\n    var groupId = getValueByDimension(data, dataIndex, groupIdDim);\n    return groupId;\n  }\n  // try to get groupId from raw data item\n  var rawDataItem = data.getRawDataItem(dataIndex);\n  var property = isChild ? 'childGroupId' : 'groupId';\n  if (rawDataItem && rawDataItem[property]) {\n    return rawDataItem[property] + '';\n  }\n  // fallback\n  if (isChild) {\n    return;\n  }\n  // try to use series.dataGroupId as groupId, otherwise use dataItem's id as groupId\n  return dataGroupId || data.getId(dataIndex);\n}\n// flatten all data items from different serieses into one arrary\nfunction flattenDataDiffItems(list) {\n  var items = [];\n  each(list, function (seriesInfo) {\n    var data = seriesInfo.data;\n    var dataGroupId = seriesInfo.dataGroupId;\n    if (data.count() > DATA_COUNT_THRESHOLD) {\n      if (process.env.NODE_ENV !== 'production') {\n        warn('Universal transition is disabled on large data > 10k.');\n      }\n      return;\n    }\n    var indices = data.getIndices();\n    for (var dataIndex = 0; dataIndex < indices.length; dataIndex++) {\n      items.push({\n        data: data,\n        groupId: getGroupId(data, dataIndex, dataGroupId, false),\n        childGroupId: getGroupId(data, dataIndex, dataGroupId, true),\n        divide: seriesInfo.divide,\n        dataIndex: dataIndex\n      });\n    }\n  });\n  return items;\n}\nfunction fadeInElement(newEl, newSeries, newIndex) {\n  newEl.traverse(function (el) {\n    if (el instanceof Path) {\n      // TODO use fade in animation for target element.\n      initProps(el, {\n        style: {\n          opacity: 0\n        }\n      }, newSeries, {\n        dataIndex: newIndex,\n        isFrom: true\n      });\n    }\n  });\n}\nfunction removeEl(el) {\n  if (el.parent) {\n    // Bake parent transform to element.\n    // So it can still have proper transform to transition after it's removed.\n    var computedTransform = el.getComputedTransform();\n    el.setLocalTransform(computedTransform);\n    el.parent.remove(el);\n  }\n}\nfunction stopAnimation(el) {\n  el.stopAnimation();\n  if (el.isGroup) {\n    el.traverse(function (child) {\n      child.stopAnimation();\n    });\n  }\n}\nfunction animateElementStyles(el, dataIndex, seriesModel) {\n  var animationConfig = getAnimationConfig('update', seriesModel, dataIndex);\n  animationConfig && el.traverse(function (child) {\n    if (child instanceof Displayable) {\n      var oldStyle = getOldStyle(child);\n      if (oldStyle) {\n        child.animateFrom({\n          style: oldStyle\n        }, animationConfig);\n      }\n    }\n  });\n}\nfunction isAllIdSame(oldDiffItems, newDiffItems) {\n  var len = oldDiffItems.length;\n  if (len !== newDiffItems.length) {\n    return false;\n  }\n  for (var i = 0; i < len; i++) {\n    var oldItem = oldDiffItems[i];\n    var newItem = newDiffItems[i];\n    if (oldItem.data.getId(oldItem.dataIndex) !== newItem.data.getId(newItem.dataIndex)) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction transitionBetween(oldList, newList, api) {\n  var oldDiffItems = flattenDataDiffItems(oldList);\n  var newDiffItems = flattenDataDiffItems(newList);\n  function updateMorphingPathProps(from, to, rawFrom, rawTo, animationCfg) {\n    if (rawFrom || from) {\n      to.animateFrom({\n        style: rawFrom && rawFrom !== from\n        // dividingMethod like clone may override the style(opacity)\n        // So extend it to raw style.\n        ? extend(extend({}, rawFrom.style), from.style) : from.style\n      }, animationCfg);\n    }\n  }\n  var hasMorphAnimation = false;\n  /**\n   * With groupId and childGroupId, we can build parent-child relationships between dataItems.\n   * However, we should mind the parent-child \"direction\" between old and new options.\n   *\n   * For example, suppose we have two dataItems from two series.data:\n   *\n   * dataA: [                          dataB: [\n   *   {                                 {\n   *     value: 5,                         value: 3,\n   *     groupId: 'creatures',             groupId: 'animals',\n   *     childGroupId: 'animals'           childGroupId: 'dogs'\n   *   },                                },\n   *   ...                               ...\n   * ]                                 ]\n   *\n   * where dataA is belong to optionA and dataB is belong to optionB.\n   *\n   * When we `setOption(optionB)` from optionA, we choose childGroupId of dataItemA and groupId of\n   * dataItemB as keys so the two keys are matched (both are 'animals'), then universalTransition\n   * will work. This derection is \"parent -> child\".\n   *\n   * If we `setOption(optionA)` from optionB, we also choose groupId of dataItemB and childGroupId\n   * of dataItemA as keys and universalTransition will work. This derection is \"child -> parent\".\n   *\n   * If there is no childGroupId specified, which means no multiLevelDrillDown/Up is needed and no\n   * parent-child relationship exists. This direction is \"none\".\n   *\n   * So we need to know whether to use groupId or childGroupId as the key when we call the keyGetter\n   * functions. Thus, we need to decide the direction first.\n   *\n   * The rule is:\n   *\n   * if (all childGroupIds in oldDiffItems and all groupIds in newDiffItems have common value) {\n   *   direction = 'parent -> child';\n   * } else if (all groupIds in oldDiffItems and all childGroupIds in newDiffItems have common value) {\n   *   direction = 'child -> parent';\n   * } else {\n   *   direction = 'none';\n   * }\n   */\n  var direction = TRANSITION_NONE;\n  // find all groupIds and childGroupIds from oldDiffItems\n  var oldGroupIds = createHashMap();\n  var oldChildGroupIds = createHashMap();\n  oldDiffItems.forEach(function (item) {\n    item.groupId && oldGroupIds.set(item.groupId, true);\n    item.childGroupId && oldChildGroupIds.set(item.childGroupId, true);\n  });\n  // traverse newDiffItems and decide the direction according to the rule\n  for (var i = 0; i < newDiffItems.length; i++) {\n    var newGroupId = newDiffItems[i].groupId;\n    if (oldChildGroupIds.get(newGroupId)) {\n      direction = TRANSITION_P2C;\n      break;\n    }\n    var newChildGroupId = newDiffItems[i].childGroupId;\n    if (newChildGroupId && oldGroupIds.get(newChildGroupId)) {\n      direction = TRANSITION_C2P;\n      break;\n    }\n  }\n  function createKeyGetter(isOld, onlyGetId) {\n    return function (diffItem) {\n      var data = diffItem.data;\n      var dataIndex = diffItem.dataIndex;\n      // TODO if specified dim\n      if (onlyGetId) {\n        return data.getId(dataIndex);\n      }\n      if (isOld) {\n        return direction === TRANSITION_P2C ? diffItem.childGroupId : diffItem.groupId;\n      } else {\n        return direction === TRANSITION_C2P ? diffItem.childGroupId : diffItem.groupId;\n      }\n    };\n  }\n  // Use id if it's very likely to be an one to one animation\n  // It's more robust than groupId\n  // TODO Check if key dimension is specified.\n  var useId = isAllIdSame(oldDiffItems, newDiffItems);\n  var isElementStillInChart = {};\n  if (!useId) {\n    // We may have different diff strategy with basicTransition if we use other dimension as key.\n    // If so, we can't simply check if oldEl is same with newEl. We need a map to check if oldEl is still being used in the new chart.\n    // We can't use the elements that already being morphed. Let it keep it's original basic transition.\n    for (var i = 0; i < newDiffItems.length; i++) {\n      var newItem = newDiffItems[i];\n      var el = newItem.data.getItemGraphicEl(newItem.dataIndex);\n      if (el) {\n        isElementStillInChart[el.id] = true;\n      }\n    }\n  }\n  function updateOneToOne(newIndex, oldIndex) {\n    var oldItem = oldDiffItems[oldIndex];\n    var newItem = newDiffItems[newIndex];\n    var newSeries = newItem.data.hostModel;\n    // TODO Mark this elements is morphed and don't morph them anymore\n    var oldEl = oldItem.data.getItemGraphicEl(oldItem.dataIndex);\n    var newEl = newItem.data.getItemGraphicEl(newItem.dataIndex);\n    // Can't handle same elements.\n    if (oldEl === newEl) {\n      newEl && animateElementStyles(newEl, newItem.dataIndex, newSeries);\n      return;\n    }\n    if (\n    // We can't use the elements that already being morphed\n    oldEl && isElementStillInChart[oldEl.id]) {\n      return;\n    }\n    if (newEl) {\n      // TODO: If keep animating the group in case\n      // some of the elements don't want to be morphed.\n      // TODO Label?\n      stopAnimation(newEl);\n      if (oldEl) {\n        stopAnimation(oldEl);\n        // If old element is doing leaving animation. stop it and remove it immediately.\n        removeEl(oldEl);\n        hasMorphAnimation = true;\n        applyMorphAnimation(getPathList(oldEl), getPathList(newEl), newItem.divide, newSeries, newIndex, updateMorphingPathProps);\n      } else {\n        fadeInElement(newEl, newSeries, newIndex);\n      }\n    }\n    // else keep oldEl leaving animation.\n  }\n\n  new DataDiffer(oldDiffItems, newDiffItems, createKeyGetter(true, useId), createKeyGetter(false, useId), null, 'multiple').update(updateOneToOne).updateManyToOne(function (newIndex, oldIndices) {\n    var newItem = newDiffItems[newIndex];\n    var newData = newItem.data;\n    var newSeries = newData.hostModel;\n    var newEl = newData.getItemGraphicEl(newItem.dataIndex);\n    var oldElsList = filter(map(oldIndices, function (idx) {\n      return oldDiffItems[idx].data.getItemGraphicEl(oldDiffItems[idx].dataIndex);\n    }), function (oldEl) {\n      return oldEl && oldEl !== newEl && !isElementStillInChart[oldEl.id];\n    });\n    if (newEl) {\n      stopAnimation(newEl);\n      if (oldElsList.length) {\n        // If old element is doing leaving animation. stop it and remove it immediately.\n        each(oldElsList, function (oldEl) {\n          stopAnimation(oldEl);\n          removeEl(oldEl);\n        });\n        hasMorphAnimation = true;\n        applyMorphAnimation(getPathList(oldElsList), getPathList(newEl), newItem.divide, newSeries, newIndex, updateMorphingPathProps);\n      } else {\n        fadeInElement(newEl, newSeries, newItem.dataIndex);\n      }\n    }\n    // else keep oldEl leaving animation.\n  }).updateOneToMany(function (newIndices, oldIndex) {\n    var oldItem = oldDiffItems[oldIndex];\n    var oldEl = oldItem.data.getItemGraphicEl(oldItem.dataIndex);\n    // We can't use the elements that already being morphed\n    if (oldEl && isElementStillInChart[oldEl.id]) {\n      return;\n    }\n    var newElsList = filter(map(newIndices, function (idx) {\n      return newDiffItems[idx].data.getItemGraphicEl(newDiffItems[idx].dataIndex);\n    }), function (el) {\n      return el && el !== oldEl;\n    });\n    var newSeris = newDiffItems[newIndices[0]].data.hostModel;\n    if (newElsList.length) {\n      each(newElsList, function (newEl) {\n        return stopAnimation(newEl);\n      });\n      if (oldEl) {\n        stopAnimation(oldEl);\n        // If old element is doing leaving animation. stop it and remove it immediately.\n        removeEl(oldEl);\n        hasMorphAnimation = true;\n        applyMorphAnimation(getPathList(oldEl), getPathList(newElsList), oldItem.divide,\n        // Use divide on old.\n        newSeris, newIndices[0], updateMorphingPathProps);\n      } else {\n        each(newElsList, function (newEl) {\n          return fadeInElement(newEl, newSeris, newIndices[0]);\n        });\n      }\n    }\n    // else keep oldEl leaving animation.\n  }).updateManyToMany(function (newIndices, oldIndices) {\n    // If two data are same and both have groupId.\n    // Normally they should be diff by id.\n    new DataDiffer(oldIndices, newIndices, function (rawIdx) {\n      return oldDiffItems[rawIdx].data.getId(oldDiffItems[rawIdx].dataIndex);\n    }, function (rawIdx) {\n      return newDiffItems[rawIdx].data.getId(newDiffItems[rawIdx].dataIndex);\n    }).update(function (newIndex, oldIndex) {\n      // Use the original index\n      updateOneToOne(newIndices[newIndex], oldIndices[oldIndex]);\n    }).execute();\n  }).execute();\n  if (hasMorphAnimation) {\n    each(newList, function (_a) {\n      var data = _a.data;\n      var seriesModel = data.hostModel;\n      var view = seriesModel && api.getViewOfSeriesModel(seriesModel);\n      var animationCfg = getAnimationConfig('update', seriesModel, 0); // use 0 index.\n      if (view && seriesModel.isAnimationEnabled() && animationCfg && animationCfg.duration > 0) {\n        view.group.traverse(function (el) {\n          if (el instanceof Path && !el.animators.length) {\n            // We can't accept there still exists element that has no animation\n            // if universalTransition is enabled\n            el.animateFrom({\n              style: {\n                opacity: 0\n              }\n            }, animationCfg);\n          }\n        });\n      }\n    });\n  }\n}\nfunction getSeriesTransitionKey(series) {\n  var seriesKey = series.getModel('universalTransition').get('seriesKey');\n  if (!seriesKey) {\n    // Use series id by default.\n    return series.id;\n  }\n  return seriesKey;\n}\nfunction convertArraySeriesKeyToString(seriesKey) {\n  if (isArray(seriesKey)) {\n    // Order independent.\n    return seriesKey.sort().join(',');\n  }\n  return seriesKey;\n}\nfunction getDivideShapeFromData(data) {\n  if (data.hostModel) {\n    return data.hostModel.getModel('universalTransition').get('divideShape');\n  }\n}\nfunction findTransitionSeriesBatches(globalStore, params) {\n  var updateBatches = createHashMap();\n  var oldDataMap = createHashMap();\n  // Map that only store key in array seriesKey.\n  // Which is used to query the old data when transition from one to multiple series.\n  var oldDataMapForSplit = createHashMap();\n  each(globalStore.oldSeries, function (series, idx) {\n    var oldDataGroupId = globalStore.oldDataGroupIds[idx];\n    var oldData = globalStore.oldData[idx];\n    var transitionKey = getSeriesTransitionKey(series);\n    var transitionKeyStr = convertArraySeriesKeyToString(transitionKey);\n    oldDataMap.set(transitionKeyStr, {\n      dataGroupId: oldDataGroupId,\n      data: oldData\n    });\n    if (isArray(transitionKey)) {\n      // Same key can't in different array seriesKey.\n      each(transitionKey, function (key) {\n        oldDataMapForSplit.set(key, {\n          key: transitionKeyStr,\n          dataGroupId: oldDataGroupId,\n          data: oldData\n        });\n      });\n    }\n  });\n  function checkTransitionSeriesKeyDuplicated(transitionKeyStr) {\n    if (updateBatches.get(transitionKeyStr)) {\n      warn(\"Duplicated seriesKey in universalTransition \" + transitionKeyStr);\n    }\n  }\n  each(params.updatedSeries, function (series) {\n    if (series.isUniversalTransitionEnabled() && series.isAnimationEnabled()) {\n      var newDataGroupId = series.get('dataGroupId');\n      var newData = series.getData();\n      var transitionKey = getSeriesTransitionKey(series);\n      var transitionKeyStr = convertArraySeriesKeyToString(transitionKey);\n      // Only transition between series with same id.\n      var oldData = oldDataMap.get(transitionKeyStr);\n      // string transition key is the best match.\n      if (oldData) {\n        if (process.env.NODE_ENV !== 'production') {\n          checkTransitionSeriesKeyDuplicated(transitionKeyStr);\n        }\n        // TODO check if data is same?\n        updateBatches.set(transitionKeyStr, {\n          oldSeries: [{\n            dataGroupId: oldData.dataGroupId,\n            divide: getDivideShapeFromData(oldData.data),\n            data: oldData.data\n          }],\n          newSeries: [{\n            dataGroupId: newDataGroupId,\n            divide: getDivideShapeFromData(newData),\n            data: newData\n          }]\n        });\n      } else {\n        // Transition from multiple series.\n        // e.g. 'female', 'male' -> ['female', 'male']\n        if (isArray(transitionKey)) {\n          if (process.env.NODE_ENV !== 'production') {\n            checkTransitionSeriesKeyDuplicated(transitionKeyStr);\n          }\n          var oldSeries_1 = [];\n          each(transitionKey, function (key) {\n            var oldData = oldDataMap.get(key);\n            if (oldData.data) {\n              oldSeries_1.push({\n                dataGroupId: oldData.dataGroupId,\n                divide: getDivideShapeFromData(oldData.data),\n                data: oldData.data\n              });\n            }\n          });\n          if (oldSeries_1.length) {\n            updateBatches.set(transitionKeyStr, {\n              oldSeries: oldSeries_1,\n              newSeries: [{\n                dataGroupId: newDataGroupId,\n                data: newData,\n                divide: getDivideShapeFromData(newData)\n              }]\n            });\n          }\n        } else {\n          // Try transition to multiple series.\n          // e.g. ['female', 'male'] -> 'female', 'male'\n          var oldData_1 = oldDataMapForSplit.get(transitionKey);\n          if (oldData_1) {\n            var batch = updateBatches.get(oldData_1.key);\n            if (!batch) {\n              batch = {\n                oldSeries: [{\n                  dataGroupId: oldData_1.dataGroupId,\n                  data: oldData_1.data,\n                  divide: getDivideShapeFromData(oldData_1.data)\n                }],\n                newSeries: []\n              };\n              updateBatches.set(oldData_1.key, batch);\n            }\n            batch.newSeries.push({\n              dataGroupId: newDataGroupId,\n              data: newData,\n              divide: getDivideShapeFromData(newData)\n            });\n          }\n        }\n      }\n    }\n  });\n  return updateBatches;\n}\nfunction querySeries(series, finder) {\n  for (var i = 0; i < series.length; i++) {\n    var found = finder.seriesIndex != null && finder.seriesIndex === series[i].seriesIndex || finder.seriesId != null && finder.seriesId === series[i].id;\n    if (found) {\n      return i;\n    }\n  }\n}\nfunction transitionSeriesFromOpt(transitionOpt, globalStore, params, api) {\n  var from = [];\n  var to = [];\n  each(normalizeToArray(transitionOpt.from), function (finder) {\n    var idx = querySeries(globalStore.oldSeries, finder);\n    if (idx >= 0) {\n      from.push({\n        dataGroupId: globalStore.oldDataGroupIds[idx],\n        data: globalStore.oldData[idx],\n        // TODO can specify divideShape in transition.\n        divide: getDivideShapeFromData(globalStore.oldData[idx]),\n        groupIdDim: finder.dimension\n      });\n    }\n  });\n  each(normalizeToArray(transitionOpt.to), function (finder) {\n    var idx = querySeries(params.updatedSeries, finder);\n    if (idx >= 0) {\n      var data = params.updatedSeries[idx].getData();\n      to.push({\n        dataGroupId: globalStore.oldDataGroupIds[idx],\n        data: data,\n        divide: getDivideShapeFromData(data),\n        groupIdDim: finder.dimension\n      });\n    }\n  });\n  if (from.length > 0 && to.length > 0) {\n    transitionBetween(from, to, api);\n  }\n}\nexport function installUniversalTransition(registers) {\n  registers.registerUpdateLifecycle('series:beforeupdate', function (ecMOdel, api, params) {\n    each(normalizeToArray(params.seriesTransition), function (transOpt) {\n      each(normalizeToArray(transOpt.to), function (finder) {\n        var series = params.updatedSeries;\n        for (var i = 0; i < series.length; i++) {\n          if (finder.seriesIndex != null && finder.seriesIndex === series[i].seriesIndex || finder.seriesId != null && finder.seriesId === series[i].id) {\n            series[i][SERIES_UNIVERSAL_TRANSITION_PROP] = true;\n          }\n        }\n      });\n    });\n  });\n  registers.registerUpdateLifecycle('series:transition', function (ecModel, api, params) {\n    // TODO api provide an namespace that can save stuff per instance\n    var globalStore = getUniversalTransitionGlobalStore(api);\n    // TODO multiple to multiple series.\n    if (globalStore.oldSeries && params.updatedSeries && params.optionChanged) {\n      // TODO transitionOpt was used in an old implementation and can be removed now\n      // Use give transition config if its' give;\n      var transitionOpt = params.seriesTransition;\n      if (transitionOpt) {\n        each(normalizeToArray(transitionOpt), function (opt) {\n          transitionSeriesFromOpt(opt, globalStore, params, api);\n        });\n      } else {\n        // Else guess from series based on transition series key.\n        var updateBatches_1 = findTransitionSeriesBatches(globalStore, params);\n        each(updateBatches_1.keys(), function (key) {\n          var batch = updateBatches_1.get(key);\n          transitionBetween(batch.oldSeries, batch.newSeries, api);\n        });\n      }\n      // Reset\n      each(params.updatedSeries, function (series) {\n        // Reset;\n        if (series[SERIES_UNIVERSAL_TRANSITION_PROP]) {\n          series[SERIES_UNIVERSAL_TRANSITION_PROP] = false;\n        }\n      });\n    }\n    // Save all series of current update. Not only the updated one.\n    var allSeries = ecModel.getSeries();\n    var savedSeries = globalStore.oldSeries = [];\n    var savedDataGroupIds = globalStore.oldDataGroupIds = [];\n    var savedData = globalStore.oldData = [];\n    for (var i = 0; i < allSeries.length; i++) {\n      var data = allSeries[i].getData();\n      // Only save the data that can have transition.\n      // Avoid large data costing too much extra memory\n      if (data.count() < DATA_COUNT_THRESHOLD) {\n        savedSeries.push(allSeries[i]);\n        savedDataGroupIds.push(allSeries[i].get('dataGroupId'));\n        savedData.push(data);\n      }\n    }\n  });\n}","\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// TODO: move labels out of viewport.\nimport { BoundingRect, updateProps, initProps, isElementRemoved } from '../util/graphic.js';\nimport { getECData } from '../util/innerStore.js';\nimport { parsePercent } from '../util/number.js';\nimport Transformable from 'zrender/lib/core/Transformable.js';\nimport { updateLabelLinePoints, setLabelLineStyle, getLabelLineStatesModels } from './labelGuideHelper.js';\nimport { makeInner } from '../util/model.js';\nimport { retrieve2, each, keys, isFunction, filter, indexOf } from 'zrender/lib/core/util.js';\nimport { prepareLayoutList, hideOverlap, shiftLayoutOnX, shiftLayoutOnY } from './labelLayoutHelper.js';\nimport { labelInner, animateLabelValue } from './labelStyle.js';\nimport { normalizeRadian } from 'zrender/lib/contain/util.js';\nfunction cloneArr(points) {\n  if (points) {\n    var newPoints = [];\n    for (var i = 0; i < points.length; i++) {\n      newPoints.push(points[i].slice());\n    }\n    return newPoints;\n  }\n}\nfunction prepareLayoutCallbackParams(labelItem, hostEl) {\n  var label = labelItem.label;\n  var labelLine = hostEl && hostEl.getTextGuideLine();\n  return {\n    dataIndex: labelItem.dataIndex,\n    dataType: labelItem.dataType,\n    seriesIndex: labelItem.seriesModel.seriesIndex,\n    text: labelItem.label.style.text,\n    rect: labelItem.hostRect,\n    labelRect: labelItem.rect,\n    // x: labelAttr.x,\n    // y: labelAttr.y,\n    align: label.style.align,\n    verticalAlign: label.style.verticalAlign,\n    labelLinePoints: cloneArr(labelLine && labelLine.shape.points)\n  };\n}\nvar LABEL_OPTION_TO_STYLE_KEYS = ['align', 'verticalAlign', 'width', 'height', 'fontSize'];\nvar dummyTransformable = new Transformable();\nvar labelLayoutInnerStore = makeInner();\nvar labelLineAnimationStore = makeInner();\nfunction extendWithKeys(target, source, keys) {\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    if (source[key] != null) {\n      target[key] = source[key];\n    }\n  }\n}\nvar LABEL_LAYOUT_PROPS = ['x', 'y', 'rotation'];\nvar LabelManager = /** @class */function () {\n  function LabelManager() {\n    this._labelList = [];\n    this._chartViewList = [];\n  }\n  LabelManager.prototype.clearLabels = function () {\n    this._labelList = [];\n    this._chartViewList = [];\n  };\n  /**\n   * Add label to manager\n   */\n  LabelManager.prototype._addLabel = function (dataIndex, dataType, seriesModel, label, layoutOption) {\n    var labelStyle = label.style;\n    var hostEl = label.__hostTarget;\n    var textConfig = hostEl.textConfig || {};\n    // TODO: If label is in other state.\n    var labelTransform = label.getComputedTransform();\n    var labelRect = label.getBoundingRect().plain();\n    BoundingRect.applyTransform(labelRect, labelRect, labelTransform);\n    if (labelTransform) {\n      dummyTransformable.setLocalTransform(labelTransform);\n    } else {\n      // Identity transform.\n      dummyTransformable.x = dummyTransformable.y = dummyTransformable.rotation = dummyTransformable.originX = dummyTransformable.originY = 0;\n      dummyTransformable.scaleX = dummyTransformable.scaleY = 1;\n    }\n    dummyTransformable.rotation = normalizeRadian(dummyTransformable.rotation);\n    var host = label.__hostTarget;\n    var hostRect;\n    if (host) {\n      hostRect = host.getBoundingRect().plain();\n      var transform = host.getComputedTransform();\n      BoundingRect.applyTransform(hostRect, hostRect, transform);\n    }\n    var labelGuide = hostRect && host.getTextGuideLine();\n    this._labelList.push({\n      label: label,\n      labelLine: labelGuide,\n      seriesModel: seriesModel,\n      dataIndex: dataIndex,\n      dataType: dataType,\n      layoutOption: layoutOption,\n      computedLayoutOption: null,\n      rect: labelRect,\n      hostRect: hostRect,\n      // Label with lower priority will be hidden when overlapped\n      // Use rect size as default priority\n      priority: hostRect ? hostRect.width * hostRect.height : 0,\n      // Save default label attributes.\n      // For restore if developers want get back to default value in callback.\n      defaultAttr: {\n        ignore: label.ignore,\n        labelGuideIgnore: labelGuide && labelGuide.ignore,\n        x: dummyTransformable.x,\n        y: dummyTransformable.y,\n        scaleX: dummyTransformable.scaleX,\n        scaleY: dummyTransformable.scaleY,\n        rotation: dummyTransformable.rotation,\n        style: {\n          x: labelStyle.x,\n          y: labelStyle.y,\n          align: labelStyle.align,\n          verticalAlign: labelStyle.verticalAlign,\n          width: labelStyle.width,\n          height: labelStyle.height,\n          fontSize: labelStyle.fontSize\n        },\n        cursor: label.cursor,\n        attachedPos: textConfig.position,\n        attachedRot: textConfig.rotation\n      }\n    });\n  };\n  LabelManager.prototype.addLabelsOfSeries = function (chartView) {\n    var _this = this;\n    this._chartViewList.push(chartView);\n    var seriesModel = chartView.__model;\n    var layoutOption = seriesModel.get('labelLayout');\n    /**\n     * Ignore layouting if it's not specified anything.\n     */\n    if (!(isFunction(layoutOption) || keys(layoutOption).length)) {\n      return;\n    }\n    chartView.group.traverse(function (child) {\n      if (child.ignore) {\n        return true; // Stop traverse descendants.\n      }\n      // Only support label being hosted on graphic elements.\n      var textEl = child.getTextContent();\n      var ecData = getECData(child);\n      // Can only attach the text on the element with dataIndex\n      if (textEl && !textEl.disableLabelLayout) {\n        _this._addLabel(ecData.dataIndex, ecData.dataType, seriesModel, textEl, layoutOption);\n      }\n    });\n  };\n  LabelManager.prototype.updateLayoutConfig = function (api) {\n    var width = api.getWidth();\n    var height = api.getHeight();\n    function createDragHandler(el, labelLineModel) {\n      return function () {\n        updateLabelLinePoints(el, labelLineModel);\n      };\n    }\n    for (var i = 0; i < this._labelList.length; i++) {\n      var labelItem = this._labelList[i];\n      var label = labelItem.label;\n      var hostEl = label.__hostTarget;\n      var defaultLabelAttr = labelItem.defaultAttr;\n      var layoutOption = void 0;\n      // TODO A global layout option?\n      if (isFunction(labelItem.layoutOption)) {\n        layoutOption = labelItem.layoutOption(prepareLayoutCallbackParams(labelItem, hostEl));\n      } else {\n        layoutOption = labelItem.layoutOption;\n      }\n      layoutOption = layoutOption || {};\n      labelItem.computedLayoutOption = layoutOption;\n      var degreeToRadian = Math.PI / 180;\n      // TODO hostEl should always exists.\n      // Or label should not have parent because the x, y is all in global space.\n      if (hostEl) {\n        hostEl.setTextConfig({\n          // Force to set local false.\n          local: false,\n          // Ignore position and rotation config on the host el if x or y is changed.\n          position: layoutOption.x != null || layoutOption.y != null ? null : defaultLabelAttr.attachedPos,\n          // Ignore rotation config on the host el if rotation is changed.\n          rotation: layoutOption.rotate != null ? layoutOption.rotate * degreeToRadian : defaultLabelAttr.attachedRot,\n          offset: [layoutOption.dx || 0, layoutOption.dy || 0]\n        });\n      }\n      var needsUpdateLabelLine = false;\n      if (layoutOption.x != null) {\n        // TODO width of chart view.\n        label.x = parsePercent(layoutOption.x, width);\n        label.setStyle('x', 0); // Ignore movement in style. TODO: origin.\n        needsUpdateLabelLine = true;\n      } else {\n        label.x = defaultLabelAttr.x;\n        label.setStyle('x', defaultLabelAttr.style.x);\n      }\n      if (layoutOption.y != null) {\n        // TODO height of chart view.\n        label.y = parsePercent(layoutOption.y, height);\n        label.setStyle('y', 0); // Ignore movement in style.\n        needsUpdateLabelLine = true;\n      } else {\n        label.y = defaultLabelAttr.y;\n        label.setStyle('y', defaultLabelAttr.style.y);\n      }\n      if (layoutOption.labelLinePoints) {\n        var guideLine = hostEl.getTextGuideLine();\n        if (guideLine) {\n          guideLine.setShape({\n            points: layoutOption.labelLinePoints\n          });\n          // Not update\n          needsUpdateLabelLine = false;\n        }\n      }\n      var labelLayoutStore = labelLayoutInnerStore(label);\n      labelLayoutStore.needsUpdateLabelLine = needsUpdateLabelLine;\n      label.rotation = layoutOption.rotate != null ? layoutOption.rotate * degreeToRadian : defaultLabelAttr.rotation;\n      label.scaleX = defaultLabelAttr.scaleX;\n      label.scaleY = defaultLabelAttr.scaleY;\n      for (var k = 0; k < LABEL_OPTION_TO_STYLE_KEYS.length; k++) {\n        var key = LABEL_OPTION_TO_STYLE_KEYS[k];\n        label.setStyle(key, layoutOption[key] != null ? layoutOption[key] : defaultLabelAttr.style[key]);\n      }\n      if (layoutOption.draggable) {\n        label.draggable = true;\n        label.cursor = 'move';\n        if (hostEl) {\n          var hostModel = labelItem.seriesModel;\n          if (labelItem.dataIndex != null) {\n            var data = labelItem.seriesModel.getData(labelItem.dataType);\n            hostModel = data.getItemModel(labelItem.dataIndex);\n          }\n          label.on('drag', createDragHandler(hostEl, hostModel.getModel('labelLine')));\n        }\n      } else {\n        // TODO Other drag functions?\n        label.off('drag');\n        label.cursor = defaultLabelAttr.cursor;\n      }\n    }\n  };\n  LabelManager.prototype.layout = function (api) {\n    var width = api.getWidth();\n    var height = api.getHeight();\n    var labelList = prepareLayoutList(this._labelList);\n    var labelsNeedsAdjustOnX = filter(labelList, function (item) {\n      return item.layoutOption.moveOverlap === 'shiftX';\n    });\n    var labelsNeedsAdjustOnY = filter(labelList, function (item) {\n      return item.layoutOption.moveOverlap === 'shiftY';\n    });\n    shiftLayoutOnX(labelsNeedsAdjustOnX, 0, width);\n    shiftLayoutOnY(labelsNeedsAdjustOnY, 0, height);\n    var labelsNeedsHideOverlap = filter(labelList, function (item) {\n      return item.layoutOption.hideOverlap;\n    });\n    hideOverlap(labelsNeedsHideOverlap);\n  };\n  /**\n   * Process all labels. Not only labels with layoutOption.\n   */\n  LabelManager.prototype.processLabelsOverall = function () {\n    var _this = this;\n    each(this._chartViewList, function (chartView) {\n      var seriesModel = chartView.__model;\n      var ignoreLabelLineUpdate = chartView.ignoreLabelLineUpdate;\n      var animationEnabled = seriesModel.isAnimationEnabled();\n      chartView.group.traverse(function (child) {\n        if (child.ignore && !child.forceLabelAnimation) {\n          return true; // Stop traverse descendants.\n        }\n\n        var needsUpdateLabelLine = !ignoreLabelLineUpdate;\n        var label = child.getTextContent();\n        if (!needsUpdateLabelLine && label) {\n          needsUpdateLabelLine = labelLayoutInnerStore(label).needsUpdateLabelLine;\n        }\n        if (needsUpdateLabelLine) {\n          _this._updateLabelLine(child, seriesModel);\n        }\n        if (animationEnabled) {\n          _this._animateLabels(child, seriesModel);\n        }\n      });\n    });\n  };\n  LabelManager.prototype._updateLabelLine = function (el, seriesModel) {\n    // Only support label being hosted on graphic elements.\n    var textEl = el.getTextContent();\n    // Update label line style.\n    var ecData = getECData(el);\n    var dataIndex = ecData.dataIndex;\n    // Only support labelLine on the labels represent data.\n    if (textEl && dataIndex != null) {\n      var data = seriesModel.getData(ecData.dataType);\n      var itemModel = data.getItemModel(dataIndex);\n      var defaultStyle = {};\n      var visualStyle = data.getItemVisual(dataIndex, 'style');\n      if (visualStyle) {\n        var visualType = data.getVisual('drawType');\n        // Default to be same with main color\n        defaultStyle.stroke = visualStyle[visualType];\n      }\n      var labelLineModel = itemModel.getModel('labelLine');\n      setLabelLineStyle(el, getLabelLineStatesModels(itemModel), defaultStyle);\n      updateLabelLinePoints(el, labelLineModel);\n    }\n  };\n  LabelManager.prototype._animateLabels = function (el, seriesModel) {\n    var textEl = el.getTextContent();\n    var guideLine = el.getTextGuideLine();\n    // Animate\n    if (textEl\n    // `forceLabelAnimation` has the highest priority\n    && (el.forceLabelAnimation || !textEl.ignore && !textEl.invisible && !el.disableLabelAnimation && !isElementRemoved(el))) {\n      var layoutStore = labelLayoutInnerStore(textEl);\n      var oldLayout = layoutStore.oldLayout;\n      var ecData = getECData(el);\n      var dataIndex = ecData.dataIndex;\n      var newProps = {\n        x: textEl.x,\n        y: textEl.y,\n        rotation: textEl.rotation\n      };\n      var data = seriesModel.getData(ecData.dataType);\n      if (!oldLayout) {\n        textEl.attr(newProps);\n        // Disable fade in animation if value animation is enabled.\n        if (!labelInner(textEl).valueAnimation) {\n          var oldOpacity = retrieve2(textEl.style.opacity, 1);\n          // Fade in animation\n          textEl.style.opacity = 0;\n          initProps(textEl, {\n            style: {\n              opacity: oldOpacity\n            }\n          }, seriesModel, dataIndex);\n        }\n      } else {\n        textEl.attr(oldLayout);\n        // Make sure the animation from is in the right status.\n        var prevStates = el.prevStates;\n        if (prevStates) {\n          if (indexOf(prevStates, 'select') >= 0) {\n            textEl.attr(layoutStore.oldLayoutSelect);\n          }\n          if (indexOf(prevStates, 'emphasis') >= 0) {\n            textEl.attr(layoutStore.oldLayoutEmphasis);\n          }\n        }\n        updateProps(textEl, newProps, seriesModel, dataIndex);\n      }\n      layoutStore.oldLayout = newProps;\n      if (textEl.states.select) {\n        var layoutSelect = layoutStore.oldLayoutSelect = {};\n        extendWithKeys(layoutSelect, newProps, LABEL_LAYOUT_PROPS);\n        extendWithKeys(layoutSelect, textEl.states.select, LABEL_LAYOUT_PROPS);\n      }\n      if (textEl.states.emphasis) {\n        var layoutEmphasis = layoutStore.oldLayoutEmphasis = {};\n        extendWithKeys(layoutEmphasis, newProps, LABEL_LAYOUT_PROPS);\n        extendWithKeys(layoutEmphasis, textEl.states.emphasis, LABEL_LAYOUT_PROPS);\n      }\n      animateLabelValue(textEl, dataIndex, data, seriesModel, seriesModel);\n    }\n    if (guideLine && !guideLine.ignore && !guideLine.invisible) {\n      var layoutStore = labelLineAnimationStore(guideLine);\n      var oldLayout = layoutStore.oldLayout;\n      var newLayout = {\n        points: guideLine.shape.points\n      };\n      if (!oldLayout) {\n        guideLine.setShape(newLayout);\n        guideLine.style.strokePercent = 0;\n        initProps(guideLine, {\n          style: {\n            strokePercent: 1\n          }\n        }, seriesModel);\n      } else {\n        guideLine.attr({\n          shape: oldLayout\n        });\n        updateProps(guideLine, {\n          shape: newLayout\n        }, seriesModel);\n      }\n      layoutStore.oldLayout = newLayout;\n    }\n  };\n  return LabelManager;\n}();\nexport default LabelManager;","\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { makeInner } from '../util/model.js';\nimport LabelManager from './LabelManager.js';\nvar getLabelManager = makeInner();\nexport function installLabelLayout(registers) {\n  registers.registerUpdateLifecycle('series:beforeupdate', function (ecModel, api, params) {\n    // TODO api provide an namespace that can save stuff per instance\n    var labelManager = getLabelManager(api).labelManager;\n    if (!labelManager) {\n      labelManager = getLabelManager(api).labelManager = new LabelManager();\n    }\n    labelManager.clearLabels();\n  });\n  registers.registerUpdateLifecycle('series:layoutlabels', function (ecModel, api, params) {\n    var labelManager = getLabelManager(api).labelManager;\n    params.updatedSeries.forEach(function (series) {\n      labelManager.addLabelsOfSeries(api.getViewOfSeriesModel(series));\n    });\n    labelManager.updateLayoutConfig(api);\n    labelManager.layout(api);\n    labelManager.processLabelsOverall();\n  });\n}","\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nfunction dataIndexMapValueLength(valNumOrArrLengthMoreThan2) {\n  return valNumOrArrLengthMoreThan2 == null ? 0 : valNumOrArrLengthMoreThan2.length || 1;\n}\nfunction defaultKeyGetter(item) {\n  return item;\n}\nvar DataDiffer = /** @class */function () {\n  /**\n   * @param context Can be visited by this.context in callback.\n   */\n  function DataDiffer(oldArr, newArr, oldKeyGetter, newKeyGetter, context,\n  // By default: 'oneToOne'.\n  diffMode) {\n    this._old = oldArr;\n    this._new = newArr;\n    this._oldKeyGetter = oldKeyGetter || defaultKeyGetter;\n    this._newKeyGetter = newKeyGetter || defaultKeyGetter;\n    // Visible in callback via `this.context`;\n    this.context = context;\n    this._diffModeMultiple = diffMode === 'multiple';\n  }\n  /**\n   * Callback function when add a data\n   */\n  DataDiffer.prototype.add = function (func) {\n    this._add = func;\n    return this;\n  };\n  /**\n   * Callback function when update a data\n   */\n  DataDiffer.prototype.update = function (func) {\n    this._update = func;\n    return this;\n  };\n  /**\n   * Callback function when update a data and only work in `cbMode: 'byKey'`.\n   */\n  DataDiffer.prototype.updateManyToOne = function (func) {\n    this._updateManyToOne = func;\n    return this;\n  };\n  /**\n   * Callback function when update a data and only work in `cbMode: 'byKey'`.\n   */\n  DataDiffer.prototype.updateOneToMany = function (func) {\n    this._updateOneToMany = func;\n    return this;\n  };\n  /**\n   * Callback function when update a data and only work in `cbMode: 'byKey'`.\n   */\n  DataDiffer.prototype.updateManyToMany = function (func) {\n    this._updateManyToMany = func;\n    return this;\n  };\n  /**\n   * Callback function when remove a data\n   */\n  DataDiffer.prototype.remove = function (func) {\n    this._remove = func;\n    return this;\n  };\n  DataDiffer.prototype.execute = function () {\n    this[this._diffModeMultiple ? '_executeMultiple' : '_executeOneToOne']();\n  };\n  DataDiffer.prototype._executeOneToOne = function () {\n    var oldArr = this._old;\n    var newArr = this._new;\n    var newDataIndexMap = {};\n    var oldDataKeyArr = new Array(oldArr.length);\n    var newDataKeyArr = new Array(newArr.length);\n    this._initIndexMap(oldArr, null, oldDataKeyArr, '_oldKeyGetter');\n    this._initIndexMap(newArr, newDataIndexMap, newDataKeyArr, '_newKeyGetter');\n    for (var i = 0; i < oldArr.length; i++) {\n      var oldKey = oldDataKeyArr[i];\n      var newIdxMapVal = newDataIndexMap[oldKey];\n      var newIdxMapValLen = dataIndexMapValueLength(newIdxMapVal);\n      // idx can never be empty array here. see 'set null' logic below.\n      if (newIdxMapValLen > 1) {\n        // Consider there is duplicate key (for example, use dataItem.name as key).\n        // We should make sure every item in newArr and oldArr can be visited.\n        var newIdx = newIdxMapVal.shift();\n        if (newIdxMapVal.length === 1) {\n          newDataIndexMap[oldKey] = newIdxMapVal[0];\n        }\n        this._update && this._update(newIdx, i);\n      } else if (newIdxMapValLen === 1) {\n        newDataIndexMap[oldKey] = null;\n        this._update && this._update(newIdxMapVal, i);\n      } else {\n        this._remove && this._remove(i);\n      }\n    }\n    this._performRestAdd(newDataKeyArr, newDataIndexMap);\n  };\n  /**\n   * For example, consider the case:\n   * oldData: [o0, o1, o2, o3, o4, o5, o6, o7],\n   * newData: [n0, n1, n2, n3, n4, n5, n6, n7, n8],\n   * Where:\n   *     o0, o1, n0 has key 'a' (many to one)\n   *     o5, n4, n5, n6 has key 'b' (one to many)\n   *     o2, n1 has key 'c' (one to one)\n   *     n2, n3 has key 'd' (add)\n   *     o3, o4 has key 'e' (remove)\n   *     o6, o7, n7, n8 has key 'f' (many to many, treated as add and remove)\n   * Then:\n   *     (The order of the following directives are not ensured.)\n   *     this._updateManyToOne(n0, [o0, o1]);\n   *     this._updateOneToMany([n4, n5, n6], o5);\n   *     this._update(n1, o2);\n   *     this._remove(o3);\n   *     this._remove(o4);\n   *     this._remove(o6);\n   *     this._remove(o7);\n   *     this._add(n2);\n   *     this._add(n3);\n   *     this._add(n7);\n   *     this._add(n8);\n   */\n  DataDiffer.prototype._executeMultiple = function () {\n    var oldArr = this._old;\n    var newArr = this._new;\n    var oldDataIndexMap = {};\n    var newDataIndexMap = {};\n    var oldDataKeyArr = [];\n    var newDataKeyArr = [];\n    this._initIndexMap(oldArr, oldDataIndexMap, oldDataKeyArr, '_oldKeyGetter');\n    this._initIndexMap(newArr, newDataIndexMap, newDataKeyArr, '_newKeyGetter');\n    for (var i = 0; i < oldDataKeyArr.length; i++) {\n      var oldKey = oldDataKeyArr[i];\n      var oldIdxMapVal = oldDataIndexMap[oldKey];\n      var newIdxMapVal = newDataIndexMap[oldKey];\n      var oldIdxMapValLen = dataIndexMapValueLength(oldIdxMapVal);\n      var newIdxMapValLen = dataIndexMapValueLength(newIdxMapVal);\n      if (oldIdxMapValLen > 1 && newIdxMapValLen === 1) {\n        this._updateManyToOne && this._updateManyToOne(newIdxMapVal, oldIdxMapVal);\n        newDataIndexMap[oldKey] = null;\n      } else if (oldIdxMapValLen === 1 && newIdxMapValLen > 1) {\n        this._updateOneToMany && this._updateOneToMany(newIdxMapVal, oldIdxMapVal);\n        newDataIndexMap[oldKey] = null;\n      } else if (oldIdxMapValLen === 1 && newIdxMapValLen === 1) {\n        this._update && this._update(newIdxMapVal, oldIdxMapVal);\n        newDataIndexMap[oldKey] = null;\n      } else if (oldIdxMapValLen > 1 && newIdxMapValLen > 1) {\n        this._updateManyToMany && this._updateManyToMany(newIdxMapVal, oldIdxMapVal);\n        newDataIndexMap[oldKey] = null;\n      } else if (oldIdxMapValLen > 1) {\n        for (var i_1 = 0; i_1 < oldIdxMapValLen; i_1++) {\n          this._remove && this._remove(oldIdxMapVal[i_1]);\n        }\n      } else {\n        this._remove && this._remove(oldIdxMapVal);\n      }\n    }\n    this._performRestAdd(newDataKeyArr, newDataIndexMap);\n  };\n  DataDiffer.prototype._performRestAdd = function (newDataKeyArr, newDataIndexMap) {\n    for (var i = 0; i < newDataKeyArr.length; i++) {\n      var newKey = newDataKeyArr[i];\n      var newIdxMapVal = newDataIndexMap[newKey];\n      var idxMapValLen = dataIndexMapValueLength(newIdxMapVal);\n      if (idxMapValLen > 1) {\n        for (var j = 0; j < idxMapValLen; j++) {\n          this._add && this._add(newIdxMapVal[j]);\n        }\n      } else if (idxMapValLen === 1) {\n        this._add && this._add(newIdxMapVal);\n      }\n      // Support both `newDataKeyArr` are duplication removed or not removed.\n      newDataIndexMap[newKey] = null;\n    }\n  };\n  DataDiffer.prototype._initIndexMap = function (arr,\n  // Can be null.\n  map,\n  // In 'byKey', the output `keyArr` is duplication removed.\n  // In 'byIndex', the output `keyArr` is not duplication removed and\n  //     its indices are accurately corresponding to `arr`.\n  keyArr, keyGetterName) {\n    var cbModeMultiple = this._diffModeMultiple;\n    for (var i = 0; i < arr.length; i++) {\n      // Add prefix to avoid conflict with Object.prototype.\n      var key = '_ec_' + this[keyGetterName](arr[i], i);\n      if (!cbModeMultiple) {\n        keyArr[i] = key;\n      }\n      if (!map) {\n        continue;\n      }\n      var idxMapVal = map[key];\n      var idxMapValLen = dataIndexMapValueLength(idxMapVal);\n      if (idxMapValLen === 0) {\n        // Simple optimize: in most cases, one index has one key,\n        // do not need array.\n        map[key] = i;\n        if (cbModeMultiple) {\n          keyArr.push(key);\n        }\n      } else if (idxMapValLen === 1) {\n        map[key] = [idxMapVal, i];\n      } else {\n        idxMapVal.push(i);\n      }\n    }\n  };\n  return DataDiffer;\n}();\nexport default DataDiffer;","\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { Point, Path, Polyline } from '../util/graphic.js';\nimport PathProxy from 'zrender/lib/core/PathProxy.js';\nimport { normalizeRadian } from 'zrender/lib/contain/util.js';\nimport { cubicProjectPoint, quadraticProjectPoint } from 'zrender/lib/core/curve.js';\nimport { defaults, retrieve2 } from 'zrender/lib/core/util.js';\nimport { invert } from 'zrender/lib/core/matrix.js';\nimport * as vector from 'zrender/lib/core/vector.js';\nimport { DISPLAY_STATES, SPECIAL_STATES } from '../util/states.js';\nvar PI2 = Math.PI * 2;\nvar CMD = PathProxy.CMD;\nvar DEFAULT_SEARCH_SPACE = ['top', 'right', 'bottom', 'left'];\nfunction getCandidateAnchor(pos, distance, rect, outPt, outDir) {\n  var width = rect.width;\n  var height = rect.height;\n  switch (pos) {\n    case 'top':\n      outPt.set(rect.x + width / 2, rect.y - distance);\n      outDir.set(0, -1);\n      break;\n    case 'bottom':\n      outPt.set(rect.x + width / 2, rect.y + height + distance);\n      outDir.set(0, 1);\n      break;\n    case 'left':\n      outPt.set(rect.x - distance, rect.y + height / 2);\n      outDir.set(-1, 0);\n      break;\n    case 'right':\n      outPt.set(rect.x + width + distance, rect.y + height / 2);\n      outDir.set(1, 0);\n      break;\n  }\n}\nfunction projectPointToArc(cx, cy, r, startAngle, endAngle, anticlockwise, x, y, out) {\n  x -= cx;\n  y -= cy;\n  var d = Math.sqrt(x * x + y * y);\n  x /= d;\n  y /= d;\n  // Intersect point.\n  var ox = x * r + cx;\n  var oy = y * r + cy;\n  if (Math.abs(startAngle - endAngle) % PI2 < 1e-4) {\n    // Is a circle\n    out[0] = ox;\n    out[1] = oy;\n    return d - r;\n  }\n  if (anticlockwise) {\n    var tmp = startAngle;\n    startAngle = normalizeRadian(endAngle);\n    endAngle = normalizeRadian(tmp);\n  } else {\n    startAngle = normalizeRadian(startAngle);\n    endAngle = normalizeRadian(endAngle);\n  }\n  if (startAngle > endAngle) {\n    endAngle += PI2;\n  }\n  var angle = Math.atan2(y, x);\n  if (angle < 0) {\n    angle += PI2;\n  }\n  if (angle >= startAngle && angle <= endAngle || angle + PI2 >= startAngle && angle + PI2 <= endAngle) {\n    // Project point is on the arc.\n    out[0] = ox;\n    out[1] = oy;\n    return d - r;\n  }\n  var x1 = r * Math.cos(startAngle) + cx;\n  var y1 = r * Math.sin(startAngle) + cy;\n  var x2 = r * Math.cos(endAngle) + cx;\n  var y2 = r * Math.sin(endAngle) + cy;\n  var d1 = (x1 - x) * (x1 - x) + (y1 - y) * (y1 - y);\n  var d2 = (x2 - x) * (x2 - x) + (y2 - y) * (y2 - y);\n  if (d1 < d2) {\n    out[0] = x1;\n    out[1] = y1;\n    return Math.sqrt(d1);\n  } else {\n    out[0] = x2;\n    out[1] = y2;\n    return Math.sqrt(d2);\n  }\n}\nfunction projectPointToLine(x1, y1, x2, y2, x, y, out, limitToEnds) {\n  var dx = x - x1;\n  var dy = y - y1;\n  var dx1 = x2 - x1;\n  var dy1 = y2 - y1;\n  var lineLen = Math.sqrt(dx1 * dx1 + dy1 * dy1);\n  dx1 /= lineLen;\n  dy1 /= lineLen;\n  // dot product\n  var projectedLen = dx * dx1 + dy * dy1;\n  var t = projectedLen / lineLen;\n  if (limitToEnds) {\n    t = Math.min(Math.max(t, 0), 1);\n  }\n  t *= lineLen;\n  var ox = out[0] = x1 + t * dx1;\n  var oy = out[1] = y1 + t * dy1;\n  return Math.sqrt((ox - x) * (ox - x) + (oy - y) * (oy - y));\n}\nfunction projectPointToRect(x1, y1, width, height, x, y, out) {\n  if (width < 0) {\n    x1 = x1 + width;\n    width = -width;\n  }\n  if (height < 0) {\n    y1 = y1 + height;\n    height = -height;\n  }\n  var x2 = x1 + width;\n  var y2 = y1 + height;\n  var ox = out[0] = Math.min(Math.max(x, x1), x2);\n  var oy = out[1] = Math.min(Math.max(y, y1), y2);\n  return Math.sqrt((ox - x) * (ox - x) + (oy - y) * (oy - y));\n}\nvar tmpPt = [];\nfunction nearestPointOnRect(pt, rect, out) {\n  var dist = projectPointToRect(rect.x, rect.y, rect.width, rect.height, pt.x, pt.y, tmpPt);\n  out.set(tmpPt[0], tmpPt[1]);\n  return dist;\n}\n/**\n * Calculate min distance corresponding point.\n * This method won't evaluate if point is in the path.\n */\nfunction nearestPointOnPath(pt, path, out) {\n  var xi = 0;\n  var yi = 0;\n  var x0 = 0;\n  var y0 = 0;\n  var x1;\n  var y1;\n  var minDist = Infinity;\n  var data = path.data;\n  var x = pt.x;\n  var y = pt.y;\n  for (var i = 0; i < data.length;) {\n    var cmd = data[i++];\n    if (i === 1) {\n      xi = data[i];\n      yi = data[i + 1];\n      x0 = xi;\n      y0 = yi;\n    }\n    var d = minDist;\n    switch (cmd) {\n      case CMD.M:\n        // moveTo  subpath, \n        //  closePath \n        x0 = data[i++];\n        y0 = data[i++];\n        xi = x0;\n        yi = y0;\n        break;\n      case CMD.L:\n        d = projectPointToLine(xi, yi, data[i], data[i + 1], x, y, tmpPt, true);\n        xi = data[i++];\n        yi = data[i++];\n        break;\n      case CMD.C:\n        d = cubicProjectPoint(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], x, y, tmpPt);\n        xi = data[i++];\n        yi = data[i++];\n        break;\n      case CMD.Q:\n        d = quadraticProjectPoint(xi, yi, data[i++], data[i++], data[i], data[i + 1], x, y, tmpPt);\n        xi = data[i++];\n        yi = data[i++];\n        break;\n      case CMD.A:\n        // TODO Arc \n        var cx = data[i++];\n        var cy = data[i++];\n        var rx = data[i++];\n        var ry = data[i++];\n        var theta = data[i++];\n        var dTheta = data[i++];\n        // TODO Arc \n        i += 1;\n        var anticlockwise = !!(1 - data[i++]);\n        x1 = Math.cos(theta) * rx + cx;\n        y1 = Math.sin(theta) * ry + cy;\n        //  arc \n        if (i <= 1) {\n          // \n          x0 = x1;\n          y0 = y1;\n        }\n        // zr scale, x\n        var _x = (x - cx) * ry / rx + cx;\n        d = projectPointToArc(cx, cy, ry, theta, theta + dTheta, anticlockwise, _x, y, tmpPt);\n        xi = Math.cos(theta + dTheta) * rx + cx;\n        yi = Math.sin(theta + dTheta) * ry + cy;\n        break;\n      case CMD.R:\n        x0 = xi = data[i++];\n        y0 = yi = data[i++];\n        var width = data[i++];\n        var height = data[i++];\n        d = projectPointToRect(x0, y0, width, height, x, y, tmpPt);\n        break;\n      case CMD.Z:\n        d = projectPointToLine(xi, yi, x0, y0, x, y, tmpPt, true);\n        xi = x0;\n        yi = y0;\n        break;\n    }\n    if (d < minDist) {\n      minDist = d;\n      out.set(tmpPt[0], tmpPt[1]);\n    }\n  }\n  return minDist;\n}\n// Temporal variable for intermediate usage.\nvar pt0 = new Point();\nvar pt1 = new Point();\nvar pt2 = new Point();\nvar dir = new Point();\nvar dir2 = new Point();\n/**\n * Calculate a proper guide line based on the label position and graphic element definition\n * @param label\n * @param labelRect\n * @param target\n * @param targetRect\n */\nexport function updateLabelLinePoints(target, labelLineModel) {\n  if (!target) {\n    return;\n  }\n  var labelLine = target.getTextGuideLine();\n  var label = target.getTextContent();\n  // Needs to create text guide in each charts.\n  if (!(label && labelLine)) {\n    return;\n  }\n  var labelGuideConfig = target.textGuideLineConfig || {};\n  var points = [[0, 0], [0, 0], [0, 0]];\n  var searchSpace = labelGuideConfig.candidates || DEFAULT_SEARCH_SPACE;\n  var labelRect = label.getBoundingRect().clone();\n  labelRect.applyTransform(label.getComputedTransform());\n  var minDist = Infinity;\n  var anchorPoint = labelGuideConfig.anchor;\n  var targetTransform = target.getComputedTransform();\n  var targetInversedTransform = targetTransform && invert([], targetTransform);\n  var len = labelLineModel.get('length2') || 0;\n  if (anchorPoint) {\n    pt2.copy(anchorPoint);\n  }\n  for (var i = 0; i < searchSpace.length; i++) {\n    var candidate = searchSpace[i];\n    getCandidateAnchor(candidate, 0, labelRect, pt0, dir);\n    Point.scaleAndAdd(pt1, pt0, dir, len);\n    // Transform to target coord space.\n    pt1.transform(targetInversedTransform);\n    // Note: getBoundingRect will ensure the `path` being created.\n    var boundingRect = target.getBoundingRect();\n    var dist = anchorPoint ? anchorPoint.distance(pt1) : target instanceof Path ? nearestPointOnPath(pt1, target.path, pt2) : nearestPointOnRect(pt1, boundingRect, pt2);\n    // TODO pt2 is in the path\n    if (dist < minDist) {\n      minDist = dist;\n      // Transform back to global space.\n      pt1.transform(targetTransform);\n      pt2.transform(targetTransform);\n      pt2.toArray(points[0]);\n      pt1.toArray(points[1]);\n      pt0.toArray(points[2]);\n    }\n  }\n  limitTurnAngle(points, labelLineModel.get('minTurnAngle'));\n  labelLine.setShape({\n    points: points\n  });\n}\n// Temporal variable for the limitTurnAngle function\nvar tmpArr = [];\nvar tmpProjPoint = new Point();\n/**\n * Reduce the line segment attached to the label to limit the turn angle between two segments.\n * @param linePoints\n * @param minTurnAngle Radian of minimum turn angle. 0 - 180\n */\nexport function limitTurnAngle(linePoints, minTurnAngle) {\n  if (!(minTurnAngle <= 180 && minTurnAngle > 0)) {\n    return;\n  }\n  minTurnAngle = minTurnAngle / 180 * Math.PI;\n  // The line points can be\n  //      /pt1----pt2 (label)\n  //     /\n  // pt0/\n  pt0.fromArray(linePoints[0]);\n  pt1.fromArray(linePoints[1]);\n  pt2.fromArray(linePoints[2]);\n  Point.sub(dir, pt0, pt1);\n  Point.sub(dir2, pt2, pt1);\n  var len1 = dir.len();\n  var len2 = dir2.len();\n  if (len1 < 1e-3 || len2 < 1e-3) {\n    return;\n  }\n  dir.scale(1 / len1);\n  dir2.scale(1 / len2);\n  var angleCos = dir.dot(dir2);\n  var minTurnAngleCos = Math.cos(minTurnAngle);\n  if (minTurnAngleCos < angleCos) {\n    // Smaller than minTurnAngle\n    // Calculate project point of pt0 on pt1-pt2\n    var d = projectPointToLine(pt1.x, pt1.y, pt2.x, pt2.y, pt0.x, pt0.y, tmpArr, false);\n    tmpProjPoint.fromArray(tmpArr);\n    // Calculate new projected length with limited minTurnAngle and get the new connect point\n    tmpProjPoint.scaleAndAdd(dir2, d / Math.tan(Math.PI - minTurnAngle));\n    // Limit the new calculated connect point between pt1 and pt2.\n    var t = pt2.x !== pt1.x ? (tmpProjPoint.x - pt1.x) / (pt2.x - pt1.x) : (tmpProjPoint.y - pt1.y) / (pt2.y - pt1.y);\n    if (isNaN(t)) {\n      return;\n    }\n    if (t < 0) {\n      Point.copy(tmpProjPoint, pt1);\n    } else if (t > 1) {\n      Point.copy(tmpProjPoint, pt2);\n    }\n    tmpProjPoint.toArray(linePoints[1]);\n  }\n}\n/**\n * Limit the angle of line and the surface\n * @param maxSurfaceAngle Radian of minimum turn angle. 0 - 180. 0 is same direction to normal. 180 is opposite\n */\nexport function limitSurfaceAngle(linePoints, surfaceNormal, maxSurfaceAngle) {\n  if (!(maxSurfaceAngle <= 180 && maxSurfaceAngle > 0)) {\n    return;\n  }\n  maxSurfaceAngle = maxSurfaceAngle / 180 * Math.PI;\n  pt0.fromArray(linePoints[0]);\n  pt1.fromArray(linePoints[1]);\n  pt2.fromArray(linePoints[2]);\n  Point.sub(dir, pt1, pt0);\n  Point.sub(dir2, pt2, pt1);\n  var len1 = dir.len();\n  var len2 = dir2.len();\n  if (len1 < 1e-3 || len2 < 1e-3) {\n    return;\n  }\n  dir.scale(1 / len1);\n  dir2.scale(1 / len2);\n  var angleCos = dir.dot(surfaceNormal);\n  var maxSurfaceAngleCos = Math.cos(maxSurfaceAngle);\n  if (angleCos < maxSurfaceAngleCos) {\n    // Calculate project point of pt0 on pt1-pt2\n    var d = projectPointToLine(pt1.x, pt1.y, pt2.x, pt2.y, pt0.x, pt0.y, tmpArr, false);\n    tmpProjPoint.fromArray(tmpArr);\n    var HALF_PI = Math.PI / 2;\n    var angle2 = Math.acos(dir2.dot(surfaceNormal));\n    var newAngle = HALF_PI + angle2 - maxSurfaceAngle;\n    if (newAngle >= HALF_PI) {\n      // parallel\n      Point.copy(tmpProjPoint, pt2);\n    } else {\n      // Calculate new projected length with limited minTurnAngle and get the new connect point\n      tmpProjPoint.scaleAndAdd(dir2, d / Math.tan(Math.PI / 2 - newAngle));\n      // Limit the new calculated connect point between pt1 and pt2.\n      var t = pt2.x !== pt1.x ? (tmpProjPoint.x - pt1.x) / (pt2.x - pt1.x) : (tmpProjPoint.y - pt1.y) / (pt2.y - pt1.y);\n      if (isNaN(t)) {\n        return;\n      }\n      if (t < 0) {\n        Point.copy(tmpProjPoint, pt1);\n      } else if (t > 1) {\n        Point.copy(tmpProjPoint, pt2);\n      }\n    }\n    tmpProjPoint.toArray(linePoints[1]);\n  }\n}\nfunction setLabelLineState(labelLine, ignore, stateName, stateModel) {\n  var isNormal = stateName === 'normal';\n  var stateObj = isNormal ? labelLine : labelLine.ensureState(stateName);\n  // Make sure display.\n  stateObj.ignore = ignore;\n  // Set smooth\n  var smooth = stateModel.get('smooth');\n  if (smooth && smooth === true) {\n    smooth = 0.3;\n  }\n  stateObj.shape = stateObj.shape || {};\n  if (smooth > 0) {\n    stateObj.shape.smooth = smooth;\n  }\n  var styleObj = stateModel.getModel('lineStyle').getLineStyle();\n  isNormal ? labelLine.useStyle(styleObj) : stateObj.style = styleObj;\n}\nfunction buildLabelLinePath(path, shape) {\n  var smooth = shape.smooth;\n  var points = shape.points;\n  if (!points) {\n    return;\n  }\n  path.moveTo(points[0][0], points[0][1]);\n  if (smooth > 0 && points.length >= 3) {\n    var len1 = vector.dist(points[0], points[1]);\n    var len2 = vector.dist(points[1], points[2]);\n    if (!len1 || !len2) {\n      path.lineTo(points[1][0], points[1][1]);\n      path.lineTo(points[2][0], points[2][1]);\n      return;\n    }\n    var moveLen = Math.min(len1, len2) * smooth;\n    var midPoint0 = vector.lerp([], points[1], points[0], moveLen / len1);\n    var midPoint2 = vector.lerp([], points[1], points[2], moveLen / len2);\n    var midPoint1 = vector.lerp([], midPoint0, midPoint2, 0.5);\n    path.bezierCurveTo(midPoint0[0], midPoint0[1], midPoint0[0], midPoint0[1], midPoint1[0], midPoint1[1]);\n    path.bezierCurveTo(midPoint2[0], midPoint2[1], midPoint2[0], midPoint2[1], points[2][0], points[2][1]);\n  } else {\n    for (var i = 1; i < points.length; i++) {\n      path.lineTo(points[i][0], points[i][1]);\n    }\n  }\n}\n/**\n * Create a label line if necessary and set it's style.\n */\nexport function setLabelLineStyle(targetEl, statesModels, defaultStyle) {\n  var labelLine = targetEl.getTextGuideLine();\n  var label = targetEl.getTextContent();\n  if (!label) {\n    // Not show label line if there is no label.\n    if (labelLine) {\n      targetEl.removeTextGuideLine();\n    }\n    return;\n  }\n  var normalModel = statesModels.normal;\n  var showNormal = normalModel.get('show');\n  var labelIgnoreNormal = label.ignore;\n  for (var i = 0; i < DISPLAY_STATES.length; i++) {\n    var stateName = DISPLAY_STATES[i];\n    var stateModel = statesModels[stateName];\n    var isNormal = stateName === 'normal';\n    if (stateModel) {\n      var stateShow = stateModel.get('show');\n      var isLabelIgnored = isNormal ? labelIgnoreNormal : retrieve2(label.states[stateName] && label.states[stateName].ignore, labelIgnoreNormal);\n      if (isLabelIgnored // Not show when label is not shown in this state.\n      || !retrieve2(stateShow, showNormal) // Use normal state by default if not set.\n      ) {\n        var stateObj = isNormal ? labelLine : labelLine && labelLine.states[stateName];\n        if (stateObj) {\n          stateObj.ignore = true;\n        }\n        if (!!labelLine) {\n          setLabelLineState(labelLine, true, stateName, stateModel);\n        }\n        continue;\n      }\n      // Create labelLine if not exists\n      if (!labelLine) {\n        labelLine = new Polyline();\n        targetEl.setTextGuideLine(labelLine);\n        // Reset state of normal because it's new created.\n        // NOTE: NORMAL should always been the first!\n        if (!isNormal && (labelIgnoreNormal || !showNormal)) {\n          setLabelLineState(labelLine, true, 'normal', statesModels.normal);\n        }\n        // Use same state proxy.\n        if (targetEl.stateProxy) {\n          labelLine.stateProxy = targetEl.stateProxy;\n        }\n      }\n      setLabelLineState(labelLine, false, stateName, stateModel);\n    }\n  }\n  if (labelLine) {\n    defaults(labelLine.style, defaultStyle);\n    // Not fill.\n    labelLine.style.fill = null;\n    var showAbove = normalModel.get('showAbove');\n    var labelLineConfig = targetEl.textGuideLineConfig = targetEl.textGuideLineConfig || {};\n    labelLineConfig.showAbove = showAbove || false;\n    // Custom the buildPath.\n    labelLine.buildPath = buildLabelLinePath;\n  }\n}\nexport function getLabelLineStatesModels(itemModel, labelLineName) {\n  labelLineName = labelLineName || 'labelLine';\n  var statesModels = {\n    normal: itemModel.getModel(labelLineName)\n  };\n  for (var i = 0; i < SPECIAL_STATES.length; i++) {\n    var stateName = SPECIAL_STATES[i];\n    statesModels[stateName] = itemModel.getModel([stateName, labelLineName]);\n  }\n  return statesModels;\n}"],"names":["CMD","PathProxy","aroundEqual","a","b","Math","abs","pathToBezierCurves","path","currentSubpath","x1","y1","x2","y2","data","len","bezierArrayGroups","xi","yi","x0","y0","createNewSubpath","x","y","length","push","addLine","addArc","startAngle","endAngle","cx","cy","rx","ry","delta","tan","dir","c1","cos","s1","sin","c2","s2","x4","y4","hx","hy","i","cmd","isFirst","L","C","Q","M","A","anticlockwise","step","PI","angle","max","min","R","Z","adpativeBezier","x3","y3","out","scale","PIXEL_DISTANCE","PIXEL_DISTANCE_SQR","dx","dy","d","sqrt","dx1","dy1","dx2","dy2","cp1LenSqr","cp2LenSqr","projLen1","projLen2","tmpSegX","tmpSegY","cubicSubdivide","getDividingGrids","dimSize","rowDim","count","rowSize","columnSize","ratio","rowCount","ceil","columnCount","floor","grids","remained","divideSector","sectorShape","outShapes","r0","r","arcLen","deltaR","isAngleRow","row","column","newShape","clockwise","crossProduct2d","lineLineIntersect","a1x","a1y","a2x","a2y","b1x","b1y","b2x","b2y","mx","my","nx","ny","nmCrossProduct","p","Point","projPtOnLine","pt","lineA","lineB","sub","normalize","dir2","dot","addToPoly","poly","last","binaryDividePolygon","polygonShape","points","fromPoints","boundingRect","BoundingRect","width","height","pt0","pt1","intersections","p0","p1","intersectionPt","projPt","idx","sort","splitPt0","splitPt1","tmp","splitPt0Arr","splitPt1Arr","newPolyA","newPolyB","slice","splitPolygonByLine","binaryDivideRecursive","divider","shape","mid","split","OutShapeCtor","type","rectShape","isHorizontalRow","rowSizeDim","columnSizeDim","columnDim","divideRect","Rect","Sector","m","getComputedTransform","polygons","map","beziers","polygon","k","pathToPolygons","getUpdatedPathProxy","polygonConvert","polygonCount","totalArea_1","items","area","left","item","selfCount","Polygon","paths","clonePath","clone","source","target","subPath","setShape","setStyle","style","z","z2","zlevel","alignSubpath","subpath1","subpath2","len1","len2","shorterPath","shorterLen","diff","shorterBezierCount","eachCurveSubDivCount","newSubpath","actualSubDivCount","createSubpath","lastSubpathSubpath","otherSubpath","lastX","lastY","centroid","array","signedArea","j","findBestRingOffset","fromSubBeziers","toSubBeziers","fromCp","toCp","bezierCount","bestScore","Infinity","bestOffset","offset","cursorOffset","score","reverse","newArr","isCombineMorphing","__isCombineMorphing","SAVED_METHOD_PREFIX","saveAndModifyMethod","obj","methodName","modifiers","savedMethodName","originalMethod","replace","after","before","res","args","arguments","apply","this","restoreMethod","applyTransformOnBeziers","bezierCurves","mm","subBeziers","prepareMorphPath","fromPath","toPath","fromPathProxy","toPathProxy","_a","array1","array2","lastSubpath1","lastSubpath2","newArray1","newArray2","newSubpath1","newSubpath2","alignBezierCurves","fromBezierCurves","toBezierCurves","fromPathTransform","toPathTransform","transform","morphingData","fromArr","toArr","searchAngleIteration","searchAngleRange","fromNeedsReverse","result","fromSubpathBezier","toSubpathBezier","newFromSubpathBezier","newToSubpathBezier","bestAngle","tmpArr","sa","ca","newX1","newY1","i_1","from","to","rotation","findBestMorphingRotation","t","__morphT","onet","newCp","lerp","x0_1","y0_1","moveTo","lineTo","bezierCurveTo","morphPath","animationOpts","oldDone","done","oldDuring","during","animateTo","defaults","dirtyShape","createPathProxy","hilbert","minX","minY","maxX","maxY","round","s","sortPaths","pathList","xMin","yMin","xMax","yMax","cps","rect","getBoundingRect","cp","defaultDividePath","param","isMultiple","elements","isArray","prepareMorphBatches","one","many","batches","batchCount","off","moveFrom","pathDividers","params","ret","approxOpacity","pow","opacity","cloned","applyMorphAnimation","divideShape","seriesModel","dataIndex","animateOtherProps","updateAnimationCfg","getAnimationConfig","duration","animationDelay","getModel","get","animationCfg","Object","assign","setToFinal","fromIsMany","morphBatches","animateCount","animateIndex","morphOneBatch","batch","forceManyOne","batchMany","batchOne","separateAnimationCfg","dividePath","individualDelay","fromList","fromPathList","addFromPath","childrenRef","Path","separateCount","fromIndividuals","toIndividuals","toSubPathList","console","error","identityTransform","Transformable","parent","copyTransform","addToSubPathListToZr","zr","addSelfToZr","restoreToPath","removeSelfFromZr","toLen","animating_1","eachDone","indivdualAnimationOpts","delay","child","__zr","combineMorph","toPathList","fromLen","setLocalTransform","separateMorph","individualAnimationCfg","batchFrom","batchTo","getPathList","pathList_1","traverse","el","disableMorphing","invisible","ignore","DATA_COUNT_THRESHOLD","TRANSITION_NONE","TRANSITION_P2C","TRANSITION_C2P","getUniversalTransitionGlobalStore","makeInner","getGroupId","dataGroupId","isChild","groupIdDim","visualDimension","dimensions","dimInfo","getDimensionInfo","otherDims","getDimension","groupId","dimension","dimOrdinalMeta","ordinalMeta","value","name","categories","getValueByDimension","rawDataItem","getRawDataItem","property","getId","flattenDataDiffItems","list","each","seriesInfo","indices","getIndices","childGroupId","divide","fadeInElement","newEl","newSeries","newIndex","initProps","isFrom","removeEl","computedTransform","remove","stopAnimation","isGroup","transitionBetween","oldList","newList","api","oldDiffItems","newDiffItems","updateMorphingPathProps","rawFrom","rawTo","animateFrom","extend","hasMorphAnimation","direction","oldGroupIds","createHashMap","oldChildGroupIds","forEach","set","newGroupId","newChildGroupId","createKeyGetter","isOld","onlyGetId","diffItem","useId","oldItem","newItem","isAllIdSame","isElementStillInChart","getItemGraphicEl","id","updateOneToOne","oldIndex","hostModel","oldEl","animationConfig","Displayable","oldStyle","getOldStyle","animateElementStyles","DataDiffer","update","updateManyToOne","oldIndices","newData","oldElsList","filter","updateOneToMany","newIndices","newElsList","newSeris","updateManyToMany","rawIdx","execute","view","getViewOfSeriesModel","isAnimationEnabled","group","animators","getSeriesTransitionKey","series","seriesKey","convertArraySeriesKeyToString","join","getDivideShapeFromData","querySeries","finder","seriesIndex","seriesId","installUniversalTransition","registers","registerUpdateLifecycle","ecMOdel","normalizeToArray","seriesTransition","transOpt","updatedSeries","SERIES_UNIVERSAL_TRANSITION_PROP","ecModel","globalStore","oldSeries","optionChanged","transitionOpt","opt","oldDataGroupIds","oldData","getData","transitionSeriesFromOpt","updateBatches_1","updateBatches","oldDataMap","oldDataMapForSplit","oldDataGroupId","transitionKey","transitionKeyStr","key","isUniversalTransitionEnabled","newDataGroupId","oldSeries_1","oldData_1","findTransitionSeriesBatches","keys","allSeries","getSeries","savedSeries","savedDataGroupIds","savedData","cloneArr","newPoints","prepareLayoutCallbackParams","labelItem","hostEl","label","labelLine","getTextGuideLine","dataType","text","hostRect","labelRect","align","verticalAlign","labelLinePoints","LABEL_OPTION_TO_STYLE_KEYS","dummyTransformable","labelLayoutInnerStore","labelLineAnimationStore","extendWithKeys","LABEL_LAYOUT_PROPS","LabelManager","_labelList","_chartViewList","prototype","clearLabels","_addLabel","layoutOption","labelStyle","textConfig","__hostTarget","labelTransform","plain","applyTransform","originX","originY","scaleX","scaleY","normalizeRadian","host","labelGuide","computedLayoutOption","priority","defaultAttr","labelGuideIgnore","fontSize","cursor","attachedPos","position","attachedRot","addLabelsOfSeries","chartView","_this","__model","isFunction","textEl","getTextContent","ecData","getECData","disableLabelLayout","updateLayoutConfig","getWidth","getHeight","createDragHandler","labelLineModel","updateLabelLinePoints","defaultLabelAttr","degreeToRadian","setTextConfig","local","rotate","needsUpdateLabelLine","parsePercent","guideLine","draggable","getItemModel","on","layout","labelList","prepareLayoutList","labelsNeedsAdjustOnX","moveOverlap","labelsNeedsAdjustOnY","shiftLayoutOnX","shiftLayoutOnY","labelsNeedsHideOverlap","hideOverlap","processLabelsOverall","ignoreLabelLineUpdate","animationEnabled","forceLabelAnimation","_updateLabelLine","_animateLabels","itemModel","defaultStyle","visualStyle","getItemVisual","visualType","getVisual","stroke","setLabelLineStyle","getLabelLineStatesModels","disableLabelAnimation","isElementRemoved","oldLayout","layoutStore","newProps","attr","prevStates","indexOf","oldLayoutSelect","oldLayoutEmphasis","updateProps","labelInner","valueAnimation","oldOpacity","retrieve2","states","select","layoutSelect","emphasis","layoutEmphasis","animateLabelValue","newLayout","strokePercent","getLabelManager","installLabelLayout","labelManager","dataIndexMapValueLength","valNumOrArrLengthMoreThan2","defaultKeyGetter","oldArr","oldKeyGetter","newKeyGetter","context","diffMode","_old","_new","_oldKeyGetter","_newKeyGetter","_diffModeMultiple","add","func","_add","_update","_updateManyToOne","_updateOneToMany","_updateManyToMany","_remove","_executeOneToOne","newDataIndexMap","oldDataKeyArr","Array","newDataKeyArr","_initIndexMap","oldKey","newIdxMapVal","newIdxMapValLen","newIdx","shift","_performRestAdd","_executeMultiple","oldDataIndexMap","oldIdxMapVal","oldIdxMapValLen","newKey","idxMapValLen","arr","keyArr","keyGetterName","cbModeMultiple","idxMapVal","PI2","DEFAULT_SEARCH_SPACE","getCandidateAnchor","pos","distance","outPt","outDir","projectPointToArc","ox","oy","atan2","d1","d2","projectPointToLine","limitToEnds","lineLen","projectPointToRect","tmpPt","nearestPointOnRect","dist","nearestPointOnPath","minDist","cubicProjectPoint","quadraticProjectPoint","theta","dTheta","pt2","labelGuideConfig","textGuideLineConfig","searchSpace","candidates","anchorPoint","anchor","targetTransform","targetInversedTransform","invert","copy","scaleAndAdd","toArray","limitTurnAngle","tmpProjPoint","linePoints","minTurnAngle","fromArray","angleCos","isNaN","limitSurfaceAngle","surfaceNormal","maxSurfaceAngle","HALF_PI","newAngle","acos","setLabelLineState","stateName","stateModel","isNormal","stateObj","ensureState","smooth","styleObj","getLineStyle","useStyle","buildLabelLinePath","vector","moveLen","midPoint0","midPoint2","midPoint1","targetEl","statesModels","normalModel","normal","showNormal","labelIgnoreNormal","DISPLAY_STATES","stateShow","Polyline","setTextGuideLine","stateProxy","fill","showAbove","buildPath","removeTextGuideLine","labelLineName","SPECIAL_STATES"],"sourceRoot":""}